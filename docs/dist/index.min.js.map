{"version":3,"file":"index.min.js","sources":["../src/core/utils.ts","../src/core/slider.ts","../src/core/details.ts","../src/core/overflow-slider.ts"],"sourcesContent":["function generateId(prefix, i = 1) {\n    const id = `${prefix}-${i}`;\n    if (document.getElementById(id)) {\n        return generateId(prefix, i + 1);\n    }\n    return id;\n}\nfunction objectsAreEqual(obj1, obj2) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (let key of keys1) {\n        // Use `Object.prototype.hasOwnProperty.call` for better safety\n        if (!Object.prototype.hasOwnProperty.call(obj2, key) || obj1[key] !== obj2[key]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getOutermostChildrenEdgeMarginSum(el) {\n    if (el.children.length === 0) {\n        return 0;\n    }\n    // get the first child and its left margin\n    const firstChild = el.children[0];\n    const firstChildStyle = getComputedStyle(firstChild);\n    const firstChildMarginLeft = parseFloat(firstChildStyle.marginLeft);\n    // Get the last child and its right margin\n    const lastChild = el.children[el.children.length - 1];\n    const lastChildStyle = getComputedStyle(lastChild);\n    const lastChildMarginRight = parseFloat(lastChildStyle.marginRight);\n    return firstChildMarginLeft + lastChildMarginRight;\n}\nexport { generateId, objectsAreEqual, getOutermostChildrenEdgeMarginSum };\n","import details from './details';\nimport { generateId, objectsAreEqual, getOutermostChildrenEdgeMarginSum } from './utils';\nexport default function Slider(container, options, plugins) {\n    let slider;\n    let subs = {};\n    const overrideTransitions = () => {\n        slider.slides.forEach((slide) => {\n            slide.style.transition = 'none';\n        });\n    };\n    const restoreTransitions = () => {\n        slider.slides.forEach((slide) => {\n            slide.style.removeProperty('transition');\n        });\n    };\n    function init() {\n        slider.container = container;\n        // ensure container has id\n        let containerId = container.getAttribute('id');\n        if (containerId === null) {\n            containerId = generateId('overflow-slider');\n            container.setAttribute('id', containerId);\n        }\n        setSlides();\n        // CSS transitions can cause delays for calculations\n        overrideTransitions();\n        setDetails(true);\n        setActiveSlideIdx();\n        slider.on('contentsChanged', () => {\n            setSlides();\n            setDetails();\n            setActiveSlideIdx();\n        });\n        slider.on('containerSizeChanged', () => setDetails());\n        let requestId = 0;\n        const setDetailsDebounce = () => {\n            if (requestId) {\n                window.cancelAnimationFrame(requestId);\n            }\n            requestId = window.requestAnimationFrame(() => {\n                setDetails();\n                setActiveSlideIdx();\n            });\n        };\n        slider.on('scroll', setDetailsDebounce);\n        addEventListeners();\n        setDataAttributes();\n        setCSSVariables();\n        if (plugins) {\n            for (const plugin of plugins) {\n                plugin(slider);\n            }\n            // plugins may mutate layout: refresh details and derived data after they run\n            // setTimeout( () => {\n            setDetails();\n            setActiveSlideIdx();\n            setCSSVariables();\n            slider.emit('pluginsLoaded');\n            // }, 250 );\n        }\n        slider.on('detailsChanged', () => {\n            setDataAttributes();\n            setCSSVariables();\n        });\n        slider.emit('created');\n        restoreTransitions();\n        slider.container.setAttribute('data-ready', 'true');\n    }\n    ;\n    function setDetails(isInit = false) {\n        const oldDetails = slider.details;\n        const newDetails = details(slider);\n        slider.details = newDetails;\n        if (!isInit && !objectsAreEqual(oldDetails, newDetails)) {\n            slider.emit('detailsChanged');\n        }\n        else if (isInit) {\n            slider.emit('detailsChanged');\n        }\n    }\n    ;\n    function setSlides() {\n        slider.slides = Array.from(slider.container.querySelectorAll(slider.options.slidesSelector));\n    }\n    function addEventListeners() {\n        // changes to DOM\n        const observer = new MutationObserver(() => slider.emit('contentsChanged'));\n        observer.observe(slider.container, { childList: true });\n        // container size changes\n        const resizeObserver = new ResizeObserver(() => slider.emit('containerSizeChanged'));\n        resizeObserver.observe(slider.container);\n        // scroll event with debouncing\n        let scrollTimeout;\n        let nativeScrollTimeout;\n        let programmaticScrollTimeout;\n        let scrollLeft = slider.container.scrollLeft;\n        let nativeScrollLeft = slider.container.scrollLeft;\n        let programmaticScrollLeft = slider.container.scrollLeft;\n        let isScrolling = false;\n        let isUserScrolling = false;\n        let isProgrammaticScrolling = false;\n        // all types of scroll\n        slider.container.addEventListener('scroll', () => {\n            const newScrollLeft = slider.container.scrollLeft;\n            if (Math.floor(scrollLeft) !== Math.floor(newScrollLeft)) {\n                if (!isScrolling) {\n                    isScrolling = true;\n                    slider.emit('scrollStart');\n                }\n                scrollLeft = newScrollLeft;\n                clearTimeout(scrollTimeout);\n                scrollTimeout = setTimeout(() => {\n                    isScrolling = false;\n                    slider.emit('scrollEnd');\n                }, 50);\n                slider.emit('scroll');\n            }\n            // keep up nativeScrolling to take into account scroll-snap\n            if (isUserScrolling) {\n                nativeScrollHandler();\n            }\n        });\n        // user initted scroll (touchmove, mouse wheel, etc.)\n        const nativeScrollHandler = () => {\n            const newScrollLeft = slider.container.scrollLeft;\n            if (Math.floor(nativeScrollLeft) !== Math.floor(newScrollLeft) && !isProgrammaticScrolling) {\n                if (!isUserScrolling) {\n                    slider.emit('nativeScrollStart');\n                    isUserScrolling = true;\n                }\n                slider.emit('nativeScroll');\n                nativeScrollLeft = newScrollLeft;\n                clearTimeout(nativeScrollTimeout);\n                nativeScrollTimeout = setTimeout(() => {\n                    isUserScrolling = false;\n                    slider.emit('nativeScrollEnd');\n                    // update programmaticScrollLeft to match nativeScrollLeft\n                    // this prevents programmaticScroll triggering with no real change to scrollLeft\n                    programmaticScrollLeft = nativeScrollLeft;\n                }, 50);\n            }\n        };\n        slider.container.addEventListener('touchmove', nativeScrollHandler);\n        slider.container.addEventListener('mousewheel', nativeScrollHandler);\n        slider.container.addEventListener('wheel', nativeScrollHandler);\n        // programmatic scroll (scrollTo, etc.)\n        slider.on('programmaticScrollStart', () => {\n            isProgrammaticScrolling = true;\n        });\n        slider.container.addEventListener('scroll', () => {\n            const newScrollLeft = slider.container.scrollLeft;\n            if (Math.floor(programmaticScrollLeft) !== Math.floor(newScrollLeft) && !isUserScrolling && isProgrammaticScrolling) {\n                programmaticScrollLeft = newScrollLeft;\n                clearTimeout(programmaticScrollTimeout);\n                programmaticScrollTimeout = setTimeout(() => {\n                    isProgrammaticScrolling = false;\n                    slider.emit('programmaticScrollEnd');\n                    // update nativeScrollLeft to match programmaticScrollLeft\n                    // this prevents nativeScroll triggering with no real change to scrollLeft\n                    nativeScrollLeft = programmaticScrollLeft;\n                }, 50);\n                slider.emit('programmaticScroll');\n            }\n        });\n        // Fix issues on scroll snapping not working on programmatic scroll (it's not smooth)\n        // by disabling scroll snap if scrolling is programmatic\n        slider.on('programmaticScrollStart', () => {\n            slider.container.style.scrollSnapType = 'none';\n        });\n        // restore scroll snap if user scroll starts\n        slider.on('nativeScrollStart', () => {\n            slider.container.style.scrollSnapType = '';\n        });\n        // Listen for mouse down and touch start events on the document\n        // This handles both mouse clicks and touch interactions\n        let wasInteractedWith = false;\n        slider.container.addEventListener('mousedown', () => {\n            wasInteractedWith = true;\n        });\n        slider.container.addEventListener('touchstart', () => {\n            wasInteractedWith = true;\n        }, { passive: true });\n        slider.container.addEventListener('focusin', (e) => {\n            // move target parents as long as they are not the container\n            // but only if focus didn't start from mouse or touch\n            if (!wasInteractedWith) {\n                let target = e.target;\n                while (target.parentElement !== slider.container) {\n                    if (target.parentElement) {\n                        target = target.parentElement;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                ensureSlideIsInView(target, 'auto');\n            }\n            wasInteractedWith = false;\n        });\n    }\n    ;\n    function setCSSVariables() {\n        slider.options.cssVariableContainer.style.setProperty('--slider-container-height', `${slider.details.containerHeight}px`);\n        slider.options.cssVariableContainer.style.setProperty('--slider-container-width', `${slider.details.containerWidth}px`);\n        slider.options.cssVariableContainer.style.setProperty('--slider-scrollable-width', `${slider.details.scrollableAreaWidth}px`);\n        slider.options.cssVariableContainer.style.setProperty('--slider-slides-count', `${slider.details.slideCount}`);\n        slider.options.cssVariableContainer.style.setProperty('--slider-x-offset', `${getLeftOffset()}px`);\n        if (typeof slider.options.targetWidth === 'function') {\n            slider.options.cssVariableContainer.style.setProperty('--slider-container-target-width', `${slider.options.targetWidth(slider)}px`);\n        }\n    }\n    function setDataAttributes() {\n        slider.container.setAttribute('data-has-overflow', slider.details.hasOverflow ? 'true' : 'false');\n        if (slider.options.rtl) {\n            slider.container.setAttribute('dir', 'rtl');\n        }\n    }\n    function ensureSlideIsInView(slide, scrollBehavior = null) {\n        const behavior = scrollBehavior || slider.options.scrollBehavior;\n        const slideRect = slide.getBoundingClientRect();\n        const sliderRect = slider.container.getBoundingClientRect();\n        const containerWidth = slider.container.offsetWidth;\n        const scrollLeft = slider.container.scrollLeft;\n        const slideStart = slideRect.left - sliderRect.left + scrollLeft;\n        const slideEnd = slideStart + slideRect.width;\n        let scrollTarget = null;\n        if (Math.floor(slideStart) < Math.floor(scrollLeft)) {\n            scrollTarget = slideStart;\n        }\n        else if (Math.floor(slideEnd) > Math.floor(scrollLeft) + Math.floor(containerWidth)) {\n            scrollTarget = slideEnd - containerWidth;\n        }\n        else if (Math.floor(slideStart) === 0) {\n            scrollTarget = 0;\n        }\n        else {\n            scrollTarget = slideStart;\n        }\n        if (scrollTarget !== null) {\n            setTimeout((scrollTarget) => {\n                slider.emit('programmaticScrollStart');\n                slider.container.scrollTo({ left: scrollTarget, behavior: behavior });\n            }, 50, scrollTarget);\n        }\n    }\n    ;\n    function setActiveSlideIdx() {\n        const sliderRect = slider.container.getBoundingClientRect();\n        const scrollLeft = slider.getScrollLeft();\n        const slides = slider.slides;\n        let activeSlideIdx = 0;\n        let scrolledPastLastSlide = false;\n        if (slider.options.rtl) {\n            const scrolledDistance = slider.getInclusiveScrollWidth() - scrollLeft - slider.getInclusiveClientWidth();\n            const slidePositions = [];\n            for (let i = slides.length - 1; i >= 0; i--) {\n                const slideRect = slides[i].getBoundingClientRect();\n                const slideEnd = Math.abs(slideRect.left) - Math.abs(sliderRect.left) + scrolledDistance;\n                slidePositions.push({\n                    slide: slides[i],\n                    slideEnd: slideEnd,\n                });\n            }\n            let closestSlide = null;\n            let closestDistance = null;\n            for (let i = 0; i < slidePositions.length; i++) {\n                const distance = Math.abs(slidePositions[i].slideEnd - scrolledDistance);\n                if (closestDistance === null || distance < closestDistance) {\n                    closestDistance = distance;\n                    closestSlide = slidePositions[i].slide;\n                }\n            }\n            if (closestSlide) {\n                activeSlideIdx = slides.indexOf(closestSlide);\n            }\n            else {\n                activeSlideIdx = slides.length - 1;\n            }\n        }\n        else {\n            for (let i = 0; i < slides.length; i++) {\n                const slideRect = slides[i].getBoundingClientRect();\n                const slideStart = slideRect.left - sliderRect.left + scrollLeft + getGapSize();\n                if (Math.floor(slideStart) >= Math.floor(scrollLeft)) {\n                    activeSlideIdx = i;\n                    break;\n                }\n                if (i === slides.length - 1) {\n                    scrolledPastLastSlide = true;\n                }\n            }\n        }\n        if (scrolledPastLastSlide) {\n            activeSlideIdx = slides.length - 1;\n        }\n        const oldActiveSlideIdx = slider.activeSlideIdx;\n        slider.activeSlideIdx = activeSlideIdx;\n        if (oldActiveSlideIdx !== activeSlideIdx) {\n            slider.emit('activeSlideChanged');\n        }\n    }\n    function moveToSlide(idx) {\n        const slide = slider.slides[idx];\n        if (slide) {\n            ensureSlideIsInView(slide);\n        }\n    }\n    ;\n    function canMoveToSlide(idx) {\n        if (idx < 0 || idx >= slider.slides.length) {\n            return false;\n        }\n        if (idx === slider.activeSlideIdx) {\n            return false;\n        }\n        const direction = slider.options.rtl ? (idx < slider.activeSlideIdx ? 'backwards' : 'forwards') : (idx < slider.activeSlideIdx ? 'backwards' : 'forwards');\n        // check if the slide is already in view\n        const sliderRect = slider.container.getBoundingClientRect();\n        const scrollLeft = slider.getScrollLeft();\n        const containerWidth = slider.details.containerWidth;\n        const hasUpcomingContent = slider.slides.some((s, i) => {\n            if (i === slider.activeSlideIdx) {\n                return false; // skip the slide we are checking\n            }\n            const sRect = s.getBoundingClientRect();\n            const sStart = sRect.left - sliderRect.left + scrollLeft;\n            const sEnd = sStart + sRect.width;\n            if (slider.options.rtl) {\n                if (scrollLeft === 0 && slider.details.hasOverflow) {\n                    return true;\n                }\n                return (direction === 'forwards' && i > slider.activeSlideIdx && Math.floor(sStart) < Math.floor(scrollLeft)) ||\n                    (direction === 'backwards' && i < slider.activeSlideIdx && Math.floor(sEnd) > Math.floor(scrollLeft + containerWidth));\n            }\n            else {\n                return (direction === 'forwards' && i > slider.activeSlideIdx && Math.floor(sEnd) > Math.floor(scrollLeft + containerWidth)) ||\n                    (direction === 'backwards' && i < slider.activeSlideIdx && Math.floor(sStart) < Math.floor(scrollLeft));\n            }\n        });\n        return hasUpcomingContent;\n    }\n    function moveToSlideInDirection(direction) {\n        const activeSlideIdx = slider.activeSlideIdx;\n        if (direction === 'prev') {\n            if (activeSlideIdx > 0) {\n                moveToSlide(activeSlideIdx - 1);\n            }\n        }\n        else if (direction === 'next') {\n            if (activeSlideIdx < slider.slides.length - 1) {\n                moveToSlide(activeSlideIdx + 1);\n            }\n        }\n    }\n    function getInclusiveScrollWidth() {\n        return slider.container.scrollWidth + getOutermostChildrenEdgeMarginSum(slider.container);\n    }\n    ;\n    function getInclusiveClientWidth() {\n        return slider.container.clientWidth + getOutermostChildrenEdgeMarginSum(slider.container);\n    }\n    function getScrollLeft() {\n        return slider.options.rtl ? Math.abs(slider.container.scrollLeft) : slider.container.scrollLeft;\n    }\n    ;\n    function setScrollLeft(value) {\n        slider.container.scrollLeft = slider.options.rtl ? -value : value;\n    }\n    ;\n    function getGapSize() {\n        let gapSize = 0;\n        if (slider.slides.length > 1) {\n            const firstSlideRect = slider.slides[0].getBoundingClientRect();\n            const secondSlideRect = slider.slides[1].getBoundingClientRect();\n            gapSize = slider.options.rtl ? Math.abs(Math.floor(secondSlideRect.right - firstSlideRect.left)) : Math.floor(secondSlideRect.left - firstSlideRect.right);\n        }\n        return gapSize;\n    }\n    ;\n    function getLeftOffset() {\n        let offset = 0;\n        const fullWidthOffset = slider.container.getAttribute('data-full-width-offset');\n        if (fullWidthOffset) {\n            offset = parseInt(fullWidthOffset);\n        }\n        return Math.floor(offset);\n    }\n    ;\n    function moveToDirection(direction = \"prev\") {\n        const scrollStrategy = slider.options.scrollStrategy;\n        const scrollLeft = slider.container.scrollLeft;\n        const sliderRect = slider.container.getBoundingClientRect();\n        const containerWidth = slider.container.offsetWidth;\n        let targetScrollPosition = scrollLeft;\n        const realDirection = slider.options.rtl ? (direction === 'prev' ? 'next' : 'prev') : direction;\n        if (realDirection === 'prev') {\n            targetScrollPosition = Math.max(0, scrollLeft - slider.container.offsetWidth);\n        }\n        else if (realDirection === 'next') {\n            targetScrollPosition = Math.min(slider.getInclusiveScrollWidth(), scrollLeft + slider.container.offsetWidth);\n        }\n        if (scrollStrategy === 'fullSlide') {\n            let fullSlideTargetScrollPosition = null;\n            // extend targetScrollPosition to include gap\n            if (realDirection === 'prev') {\n                fullSlideTargetScrollPosition = Math.max(0, targetScrollPosition - getGapSize());\n            }\n            else {\n                fullSlideTargetScrollPosition = Math.min(slider.getInclusiveScrollWidth(), targetScrollPosition + getGapSize());\n            }\n            if (realDirection === 'next') {\n                let partialSlideFound = false;\n                for (let slide of slider.slides) {\n                    const slideRect = slide.getBoundingClientRect();\n                    const slideStart = slideRect.left - sliderRect.left + scrollLeft;\n                    const slideEnd = slideStart + slideRect.width;\n                    if (Math.floor(slideStart) < Math.floor(targetScrollPosition) && Math.floor(slideEnd) > Math.floor(targetScrollPosition)) {\n                        fullSlideTargetScrollPosition = slideStart;\n                        partialSlideFound = true;\n                        break;\n                    }\n                }\n                if (!partialSlideFound) {\n                    fullSlideTargetScrollPosition = Math.min(targetScrollPosition, slider.getInclusiveScrollWidth() - slider.container.offsetWidth);\n                }\n                if (fullSlideTargetScrollPosition) {\n                    if (Math.floor(fullSlideTargetScrollPosition) > Math.floor(scrollLeft)) {\n                        // make sure fullSlideTargetScrollPosition is possible considering the container width\n                        const maxScrollPosition = Math.floor(slider.getInclusiveScrollWidth()) - Math.floor(containerWidth);\n                        targetScrollPosition = Math.min(fullSlideTargetScrollPosition, maxScrollPosition);\n                    }\n                    else {\n                        // cannot snap to slide, move one page worth of distance\n                        targetScrollPosition = Math.min(slider.getInclusiveScrollWidth(), scrollLeft + containerWidth);\n                    }\n                }\n            }\n            else {\n                let partialSlideFound = false;\n                for (let slide of slider.slides) {\n                    const slideRect = slide.getBoundingClientRect();\n                    const slideStart = slideRect.left - sliderRect.left + scrollLeft;\n                    const slideEnd = slideStart + slideRect.width;\n                    if (Math.floor(slideStart) < Math.floor(scrollLeft) && Math.floor(slideEnd) > Math.floor(scrollLeft)) {\n                        fullSlideTargetScrollPosition = slideEnd - containerWidth;\n                        partialSlideFound = true;\n                        break;\n                    }\n                }\n                if (!partialSlideFound) {\n                    fullSlideTargetScrollPosition = Math.max(0, scrollLeft - containerWidth);\n                }\n                if (fullSlideTargetScrollPosition && Math.floor(fullSlideTargetScrollPosition) < Math.floor(scrollLeft)) {\n                    targetScrollPosition = fullSlideTargetScrollPosition;\n                }\n            }\n        }\n        // add left offset\n        const offsettedTargetScrollPosition = targetScrollPosition - getLeftOffset();\n        if (Math.floor(offsettedTargetScrollPosition) >= 0) {\n            targetScrollPosition = offsettedTargetScrollPosition;\n        }\n        slider.emit('programmaticScrollStart');\n        slider.container.style.scrollBehavior = slider.options.scrollBehavior;\n        slider.container.scrollLeft = targetScrollPosition;\n        setTimeout(() => slider.container.style.scrollBehavior = '', 50);\n    }\n    ;\n    function snapToClosestSlide(direction = \"prev\") {\n        var _a, _b;\n        const { slides, options, container } = slider;\n        const { rtl, emulateScrollSnapMaxThreshold = 10, scrollBehavior = 'smooth', } = options;\n        const isForward = rtl ? direction === 'prev' : direction === 'next';\n        const scrollPos = getScrollLeft();\n        // Get container rect once (includes any CSS transforms)\n        const containerRect = container.getBoundingClientRect();\n        const factor = rtl ? -1 : 1;\n        // Calculate target area offset if targetWidth is defined\n        let targetAreaOffset = 0;\n        if (typeof options.targetWidth === 'function') {\n            try {\n                const targetWidth = options.targetWidth(slider);\n                const containerWidth = containerRect.width;\n                if (Number.isFinite(targetWidth) && targetWidth > 0 && targetWidth < containerWidth) {\n                    targetAreaOffset = (containerWidth - targetWidth) / 2;\n                }\n            }\n            catch (error) {\n                // ignore errors, use default offset of 0\n            }\n        }\n        // Build slide metadata\n        const slideData = [...slides].map(slide => {\n            const { width } = slide.getBoundingClientRect();\n            const slideRect = slide.getBoundingClientRect();\n            // position relative to container's left edge\n            const relativeStart = (slideRect.left - containerRect.left) + scrollPos;\n            // Adjust trigger point to align with target area start instead of container edge\n            const alignmentPoint = relativeStart - targetAreaOffset;\n            const triggerPoint = Math.min(alignmentPoint + width / 2, alignmentPoint + emulateScrollSnapMaxThreshold);\n            return { start: relativeStart - targetAreaOffset, trigger: triggerPoint };\n        });\n        // Pick the target start based on drag direction\n        let targetStart = null;\n        if (isForward) {\n            const found = slideData.find(item => scrollPos <= item.trigger);\n            targetStart = (_a = found === null || found === void 0 ? void 0 : found.start) !== null && _a !== void 0 ? _a : null;\n        }\n        else {\n            const found = [...slideData].reverse().find(item => scrollPos >= item.trigger);\n            targetStart = (_b = found === null || found === void 0 ? void 0 : found.start) !== null && _b !== void 0 ? _b : null;\n        }\n        if (targetStart == null)\n            return;\n        // Clamp to zero and apply RTL factor\n        const finalLeft = Math.max(0, Math.floor(targetStart)) * factor;\n        container.scrollTo({ left: finalLeft, behavior: scrollBehavior });\n    }\n    function on(name, cb) {\n        if (!subs[name]) {\n            subs[name] = [];\n        }\n        subs[name].push(cb);\n    }\n    ;\n    function emit(name) {\n        var _a;\n        if (subs && subs[name]) {\n            subs[name].forEach(cb => {\n                cb(slider);\n            });\n        }\n        const optionCallBack = (_a = slider === null || slider === void 0 ? void 0 : slider.options) === null || _a === void 0 ? void 0 : _a[name];\n        // Type guard to check if the option callback is a function\n        if (typeof optionCallBack === 'function') {\n            optionCallBack(slider); // Type assertion here\n        }\n    }\n    ;\n    slider = {\n        emit,\n        moveToDirection,\n        canMoveToSlide,\n        moveToSlide,\n        moveToSlideInDirection,\n        snapToClosestSlide,\n        getInclusiveScrollWidth,\n        getInclusiveClientWidth,\n        getScrollLeft,\n        setScrollLeft,\n        setActiveSlideIdx,\n        on,\n        options,\n    };\n    init();\n    return slider;\n}\n","export default function details(slider) {\n    var _a;\n    let instance;\n    let hasOverflow = false;\n    let slideCount = 0;\n    let containerWidth = 0;\n    let containerHeight = 0;\n    let scrollableAreaWidth = 0;\n    let amountOfPages = 0;\n    let currentPage = 1;\n    if (Math.floor(slider.getInclusiveScrollWidth()) > Math.floor(slider.getInclusiveClientWidth())) {\n        hasOverflow = true;\n    }\n    slideCount = (_a = slider.slides.length) !== null && _a !== void 0 ? _a : 0;\n    containerWidth = slider.container.offsetWidth;\n    containerHeight = slider.container.offsetHeight;\n    scrollableAreaWidth = slider.getInclusiveScrollWidth();\n    amountOfPages = Math.ceil(scrollableAreaWidth / containerWidth);\n    if (Math.floor(slider.getScrollLeft()) >= 0) {\n        currentPage = Math.floor(slider.getScrollLeft() / containerWidth);\n        // consider as last page if the scrollLeft + containerWidth is equal to scrollWidth\n        if (Math.floor(slider.getScrollLeft() + containerWidth) === Math.floor(scrollableAreaWidth)) {\n            currentPage = amountOfPages - 1;\n        }\n    }\n    instance = {\n        hasOverflow,\n        slideCount,\n        containerWidth,\n        containerHeight,\n        scrollableAreaWidth,\n        amountOfPages,\n        currentPage,\n    };\n    return instance;\n}\n;\n","import Slider from './slider';\nexport default function OverflowSlider(container, options, plugins) {\n    try {\n        // check that container HTML element\n        if (!(container instanceof Element)) {\n            throw new Error(`Container must be HTML element, found ${typeof container}`);\n        }\n        const defaults = {\n            cssVariableContainer: container,\n            scrollBehavior: \"smooth\",\n            scrollStrategy: \"fullSlide\",\n            slidesSelector: \":scope > *\",\n            emulateScrollSnap: false,\n            emulateScrollSnapMaxThreshold: 64,\n            rtl: false,\n        };\n        const sliderOptions = Object.assign(Object.assign({}, defaults), options);\n        // disable smooth scrolling if user prefers reduced motion\n        if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {\n            sliderOptions.scrollBehavior = \"auto\";\n        }\n        return Slider(container, sliderOptions, plugins);\n    }\n    catch (e) {\n        console.error(e);\n    }\n}\n"],"names":["generateId","prefix","i","id","document","getElementById","getOutermostChildrenEdgeMarginSum","el","children","length","firstChild","firstChildStyle","getComputedStyle","firstChildMarginLeft","parseFloat","marginLeft","lastChild","lastChildStyle","marginRight","Slider","container","options","plugins","slider","subs","setDetails","isInit","oldDetails","details","newDetails","_a","instance","hasOverflow","slideCount","containerWidth","containerHeight","scrollableAreaWidth","amountOfPages","currentPage","Math","floor","getInclusiveScrollWidth","getInclusiveClientWidth","slides","offsetWidth","offsetHeight","ceil","getScrollLeft","obj1","obj2","keys1","Object","keys","keys2","key","prototype","hasOwnProperty","call","objectsAreEqual","emit","setSlides","Array","from","querySelectorAll","slidesSelector","setCSSVariables","cssVariableContainer","style","setProperty","getLeftOffset","targetWidth","setDataAttributes","setAttribute","rtl","ensureSlideIsInView","slide","scrollBehavior","behavior","slideRect","getBoundingClientRect","sliderRect","scrollLeft","slideStart","left","slideEnd","width","scrollTarget","setTimeout","scrollTo","setActiveSlideIdx","activeSlideIdx","scrolledPastLastSlide","scrolledDistance","slidePositions","abs","push","closestSlide","closestDistance","distance","indexOf","getGapSize","oldActiveSlideIdx","moveToSlide","idx","gapSize","firstSlideRect","secondSlideRect","right","offset","fullWidthOffset","getAttribute","parseInt","name","forEach","cb","optionCallBack","moveToDirection","direction","scrollStrategy","targetScrollPosition","realDirection","max","min","fullSlideTargetScrollPosition","partialSlideFound","maxScrollPosition","offsettedTargetScrollPosition","canMoveToSlide","some","s","sRect","sStart","sEnd","moveToSlideInDirection","snapToClosestSlide","_b","emulateScrollSnapMaxThreshold","isForward","scrollPos","containerRect","factor","targetAreaOffset","Number","isFinite","error","slideData","map","relativeStart","alignmentPoint","triggerPoint","start","trigger","targetStart","found","find","item","reverse","finalLeft","scrollWidth","clientWidth","setScrollLeft","value","on","containerId","transition","requestId","window","cancelAnimationFrame","requestAnimationFrame","MutationObserver","observe","childList","scrollTimeout","nativeScrollTimeout","programmaticScrollTimeout","ResizeObserver","nativeScrollLeft","programmaticScrollLeft","isScrolling","isUserScrolling","isProgrammaticScrolling","addEventListener","newScrollLeft","clearTimeout","nativeScrollHandler","scrollSnapType","wasInteractedWith","passive","e","target","parentElement","addEventListeners","plugin","removeProperty","init","Element","Error","defaults","emulateScrollSnap","sliderOptions","assign","matchMedia","matches","console"],"mappings":"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"}