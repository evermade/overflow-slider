{"version":3,"file":"index.min.js","sources":["../src/core/utils.ts","../src/core/slider.ts","../src/core/details.ts","../src/core/overflow-slider.ts"],"sourcesContent":["function generateId(prefix, i = 1) {\n    const id = `${prefix}-${i}`;\n    if (document.getElementById(id)) {\n        return generateId(prefix, i + 1);\n    }\n    return id;\n}\nfunction objectsAreEqual(obj1, obj2) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (let key of keys1) {\n        // Use `Object.prototype.hasOwnProperty.call` for better safety\n        if (!Object.prototype.hasOwnProperty.call(obj2, key) || obj1[key] !== obj2[key]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getOutermostChildrenEdgeMarginSum(el) {\n    if (el.children.length === 0) {\n        return 0;\n    }\n    // get the first child and its left margin\n    const firstChild = el.children[0];\n    const firstChildStyle = getComputedStyle(firstChild);\n    const firstChildMarginLeft = parseFloat(firstChildStyle.marginLeft);\n    // Get the last child and its right margin\n    const lastChild = el.children[el.children.length - 1];\n    const lastChildStyle = getComputedStyle(lastChild);\n    const lastChildMarginRight = parseFloat(lastChildStyle.marginRight);\n    return firstChildMarginLeft + lastChildMarginRight;\n}\nexport { generateId, objectsAreEqual, getOutermostChildrenEdgeMarginSum };\n","import details from './details';\nimport { generateId, objectsAreEqual, getOutermostChildrenEdgeMarginSum } from './utils';\nexport default function Slider(container, options, plugins) {\n    let slider;\n    let subs = {};\n    const overrideTransitions = () => {\n        slider.slides.forEach((slide) => {\n            slide.style.transition = 'none';\n        });\n    };\n    const restoreTransitions = () => {\n        slider.slides.forEach((slide) => {\n            slide.style.removeProperty('transition');\n        });\n    };\n    function init() {\n        slider.container = container;\n        // ensure container has id\n        let containerId = container.getAttribute('id');\n        if (containerId === null) {\n            containerId = generateId('overflow-slider');\n            container.setAttribute('id', containerId);\n        }\n        setSlides();\n        // CSS transitions can cause delays for calculations\n        overrideTransitions();\n        setDetails(true);\n        setActiveSlideIdx();\n        slider.on('contentsChanged', () => {\n            setSlides();\n            setDetails();\n            setActiveSlideIdx();\n        });\n        slider.on('containerSizeChanged', () => setDetails());\n        let requestId = 0;\n        const setDetailsDebounce = () => {\n            if (requestId) {\n                window.cancelAnimationFrame(requestId);\n            }\n            requestId = window.requestAnimationFrame(() => {\n                setDetails();\n                setActiveSlideIdx();\n            });\n        };\n        slider.on('scroll', setDetailsDebounce);\n        addEventListeners();\n        setDataAttributes();\n        setCSSVariables();\n        if (plugins) {\n            for (const plugin of plugins) {\n                plugin(slider);\n            }\n            // plugins may mutate layout: refresh details and derived data after they run\n            // setTimeout( () => {\n            setDetails();\n            setActiveSlideIdx();\n            setCSSVariables();\n            slider.emit('pluginsLoaded');\n            // }, 250 );\n        }\n        slider.on('detailsChanged', () => {\n            setDataAttributes();\n            setCSSVariables();\n        });\n        slider.emit('created');\n        restoreTransitions();\n        slider.container.setAttribute('data-ready', 'true');\n    }\n    ;\n    function setDetails(isInit = false) {\n        const oldDetails = slider.details;\n        const newDetails = details(slider);\n        slider.details = newDetails;\n        if (!isInit && !objectsAreEqual(oldDetails, newDetails)) {\n            slider.emit('detailsChanged');\n        }\n        else if (isInit) {\n            slider.emit('detailsChanged');\n        }\n    }\n    ;\n    function setSlides() {\n        slider.slides = Array.from(slider.container.querySelectorAll(slider.options.slidesSelector));\n    }\n    function addEventListeners() {\n        // changes to DOM\n        const observer = new MutationObserver(() => slider.emit('contentsChanged'));\n        observer.observe(slider.container, { childList: true });\n        // container size changes\n        const resizeObserver = new ResizeObserver(() => slider.emit('containerSizeChanged'));\n        resizeObserver.observe(slider.container);\n        // scroll event with debouncing\n        let scrollTimeout;\n        let nativeScrollTimeout;\n        let programmaticScrollTimeout;\n        let scrollLeft = slider.container.scrollLeft;\n        let nativeScrollLeft = slider.container.scrollLeft;\n        let programmaticScrollLeft = slider.container.scrollLeft;\n        let isScrolling = false;\n        let isUserScrolling = false;\n        let isProgrammaticScrolling = false;\n        // all types of scroll\n        slider.container.addEventListener('scroll', () => {\n            const newScrollLeft = slider.container.scrollLeft;\n            if (Math.floor(scrollLeft) !== Math.floor(newScrollLeft)) {\n                if (!isScrolling) {\n                    isScrolling = true;\n                    slider.emit('scrollStart');\n                }\n                scrollLeft = newScrollLeft;\n                clearTimeout(scrollTimeout);\n                scrollTimeout = setTimeout(() => {\n                    isScrolling = false;\n                    slider.emit('scrollEnd');\n                }, 50);\n                slider.emit('scroll');\n            }\n            // keep up nativeScrolling to take into account scroll-snap\n            if (isUserScrolling) {\n                nativeScrollHandler();\n            }\n        });\n        // user initted scroll (touchmove, mouse wheel, etc.)\n        const nativeScrollHandler = () => {\n            const newScrollLeft = slider.container.scrollLeft;\n            if (Math.floor(nativeScrollLeft) !== Math.floor(newScrollLeft) && !isProgrammaticScrolling) {\n                if (!isUserScrolling) {\n                    slider.emit('nativeScrollStart');\n                    isUserScrolling = true;\n                }\n                slider.emit('nativeScroll');\n                nativeScrollLeft = newScrollLeft;\n                clearTimeout(nativeScrollTimeout);\n                nativeScrollTimeout = setTimeout(() => {\n                    isUserScrolling = false;\n                    slider.emit('nativeScrollEnd');\n                    // update programmaticScrollLeft to match nativeScrollLeft\n                    // this prevents programmaticScroll triggering with no real change to scrollLeft\n                    programmaticScrollLeft = nativeScrollLeft;\n                }, 50);\n            }\n        };\n        slider.container.addEventListener('touchmove', nativeScrollHandler);\n        slider.container.addEventListener('mousewheel', nativeScrollHandler);\n        slider.container.addEventListener('wheel', nativeScrollHandler);\n        // programmatic scroll (scrollTo, etc.)\n        slider.on('programmaticScrollStart', () => {\n            isProgrammaticScrolling = true;\n        });\n        slider.container.addEventListener('scroll', () => {\n            const newScrollLeft = slider.container.scrollLeft;\n            if (Math.floor(programmaticScrollLeft) !== Math.floor(newScrollLeft) && !isUserScrolling && isProgrammaticScrolling) {\n                programmaticScrollLeft = newScrollLeft;\n                clearTimeout(programmaticScrollTimeout);\n                programmaticScrollTimeout = setTimeout(() => {\n                    isProgrammaticScrolling = false;\n                    slider.emit('programmaticScrollEnd');\n                    // update nativeScrollLeft to match programmaticScrollLeft\n                    // this prevents nativeScroll triggering with no real change to scrollLeft\n                    nativeScrollLeft = programmaticScrollLeft;\n                }, 50);\n                slider.emit('programmaticScroll');\n            }\n        });\n        // Fix issues on scroll snapping not working on programmatic scroll (it's not smooth)\n        // by disabling scroll snap if scrolling is programmatic\n        slider.on('programmaticScrollStart', () => {\n            slider.container.style.scrollSnapType = 'none';\n        });\n        // restore scroll snap if user scroll starts\n        slider.on('nativeScrollStart', () => {\n            slider.container.style.scrollSnapType = '';\n        });\n        // Listen for mouse down and touch start events on the document\n        // This handles both mouse clicks and touch interactions\n        let wasInteractedWith = false;\n        slider.container.addEventListener('mousedown', () => {\n            wasInteractedWith = true;\n        });\n        slider.container.addEventListener('touchstart', () => {\n            wasInteractedWith = true;\n        }, { passive: true });\n        slider.container.addEventListener('focusin', (e) => {\n            // Only handle keyboard-initiated focus (not mouse or touch)\n            if (wasInteractedWith) {\n                wasInteractedWith = false;\n                return;\n            }\n            wasInteractedWith = false;\n            // No scrolling needed if there is no overflow\n            if (!slider.details.hasOverflow) {\n                return;\n            }\n            const focusedElement = e.target;\n            // Walk up from the focused element to find the direct child (slide) of the container\n            let slide = focusedElement;\n            while (slide.parentElement !== slider.container) {\n                if (slide.parentElement) {\n                    slide = slide.parentElement;\n                }\n                else {\n                    // Focused element is not inside the slider container\n                    return;\n                }\n            }\n            // Emit programmaticScrollStart immediately so the browser's native focus\n            // scroll events are classified as programmatic (not native). This prevents\n            // nativeScrollStart from restoring scrollSnapType and fighting our correction.\n            slider.emit('programmaticScrollStart');\n            // Use setTimeout to let the browser's native focus scroll complete,\n            // then override with our WCAG-compliant scroll positioning\n            setTimeout(() => {\n                scrollFocusedSlideIntoView(slide, focusedElement);\n                slider.emit('focusScroll');\n            }, 50);\n        });\n    }\n    ;\n    function setCSSVariables() {\n        slider.options.cssVariableContainer.style.setProperty('--slider-container-height', `${slider.details.containerHeight}px`);\n        slider.options.cssVariableContainer.style.setProperty('--slider-container-width', `${slider.details.containerWidth}px`);\n        slider.options.cssVariableContainer.style.setProperty('--slider-scrollable-width', `${slider.details.scrollableAreaWidth}px`);\n        slider.options.cssVariableContainer.style.setProperty('--slider-slides-count', `${slider.details.slideCount}`);\n        slider.options.cssVariableContainer.style.setProperty('--slider-x-offset', `${getLeftOffset()}px`);\n        if (typeof slider.options.targetWidth === 'function') {\n            slider.options.cssVariableContainer.style.setProperty('--slider-container-target-width', `${slider.options.targetWidth(slider)}px`);\n        }\n    }\n    function setDataAttributes() {\n        slider.container.setAttribute('data-has-overflow', slider.details.hasOverflow ? 'true' : 'false');\n        if (slider.options.rtl) {\n            slider.container.setAttribute('dir', 'rtl');\n        }\n    }\n    function ensureSlideIsInView(slide, scrollBehavior = null) {\n        const behavior = scrollBehavior || slider.options.scrollBehavior;\n        const slideRect = slide.getBoundingClientRect();\n        const sliderRect = slider.container.getBoundingClientRect();\n        const containerWidth = slider.container.offsetWidth;\n        const scrollLeft = slider.container.scrollLeft;\n        const slideStart = slideRect.left - sliderRect.left + scrollLeft;\n        const slideEnd = slideStart + slideRect.width;\n        let scrollTarget = null;\n        if (Math.floor(slideStart) < Math.floor(scrollLeft)) {\n            scrollTarget = slideStart;\n        }\n        else if (Math.floor(slideEnd) > Math.floor(scrollLeft) + Math.floor(containerWidth)) {\n            scrollTarget = slideEnd - containerWidth;\n        }\n        else if (Math.floor(slideStart) === 0) {\n            scrollTarget = 0;\n        }\n        else {\n            scrollTarget = slideStart;\n        }\n        if (scrollTarget !== null) {\n            setTimeout((scrollTarget) => {\n                slider.emit('programmaticScrollStart');\n                slider.container.scrollTo({ left: scrollTarget, behavior: behavior });\n            }, 50, scrollTarget);\n        }\n    }\n    ;\n    /**\n     * Scrolls a focused slide (or child element) into view for WCAG AA compliance.\n     * Priority:\n     *   1. Show the full slide if it fits in the container\n     *   2. If the slide is wider than the container, show the focused element\n     *   3. If neither fits, align the leading edge (left for LTR, right for RTL)\n     */\n    function scrollFocusedSlideIntoView(slide, focusedElement) {\n        const isRtl = slider.options.rtl;\n        const containerRect = slider.container.getBoundingClientRect();\n        const containerWidth = slider.container.offsetWidth;\n        const slideRect = slide.getBoundingClientRect();\n        const scrollLeft = slider.container.scrollLeft;\n        // Calculate visual offsets relative to the container viewport\n        const slideLeftOffset = slideRect.left - containerRect.left;\n        const slideRightOffset = slideRect.right - containerRect.right;\n        // Check if slide is already fully visible (1px tolerance for sub-pixel rounding)\n        if (slideLeftOffset >= -1 && slideRightOffset <= 1) {\n            slider.container.style.scrollSnapType = '';\n            slider.emit('programmaticScrollEnd');\n            return;\n        }\n        let scrollTarget;\n        if (slideRect.width <= containerWidth) {\n            // Slide fits in container — align its leading edge to show it fully\n            if (isRtl) {\n                // RTL: align slide's right edge with container's right edge\n                scrollTarget = scrollLeft + slideRightOffset;\n            }\n            else {\n                // LTR: align slide's left edge with container's left edge\n                scrollTarget = scrollLeft + slideLeftOffset;\n            }\n        }\n        else if (focusedElement !== slide) {\n            // Slide is wider than container — try to show the focused child element\n            const focusRect = focusedElement.getBoundingClientRect();\n            const focusLeftOffset = focusRect.left - containerRect.left;\n            const focusRightOffset = focusRect.right - containerRect.right;\n            // Check if focused element is already fully visible\n            if (focusLeftOffset >= -1 && focusRightOffset <= 1) {\n                slider.container.style.scrollSnapType = '';\n                slider.emit('programmaticScrollEnd');\n                return;\n            }\n            if (focusRect.width <= containerWidth) {\n                // Focused element fits in container — align its leading edge\n                if (isRtl) {\n                    scrollTarget = scrollLeft + focusRightOffset;\n                }\n                else {\n                    scrollTarget = scrollLeft + focusLeftOffset;\n                }\n            }\n            else {\n                // Focused element is also wider than container — align leading edge\n                if (isRtl) {\n                    scrollTarget = scrollLeft + focusRightOffset;\n                }\n                else {\n                    scrollTarget = scrollLeft + focusLeftOffset;\n                }\n            }\n        }\n        else {\n            // Slide is the focused element and wider than container — align leading edge\n            if (isRtl) {\n                scrollTarget = scrollLeft + slideRightOffset;\n            }\n            else {\n                scrollTarget = scrollLeft + slideLeftOffset;\n            }\n        }\n        slider.emit('programmaticScrollStart');\n        slider.container.scrollTo({ left: scrollTarget, behavior: 'auto' });\n    }\n    ;\n    function setActiveSlideIdx() {\n        const sliderRect = slider.container.getBoundingClientRect();\n        const scrollLeft = slider.getScrollLeft();\n        const slides = slider.slides;\n        let activeSlideIdx = 0;\n        let scrolledPastLastSlide = false;\n        if (slider.options.rtl) {\n            const scrolledDistance = slider.getInclusiveScrollWidth() - scrollLeft - slider.getInclusiveClientWidth();\n            const slidePositions = [];\n            for (let i = slides.length - 1; i >= 0; i--) {\n                const slideRect = slides[i].getBoundingClientRect();\n                const slideEnd = Math.abs(slideRect.left) - Math.abs(sliderRect.left) + scrolledDistance;\n                slidePositions.push({\n                    slide: slides[i],\n                    slideEnd: slideEnd,\n                });\n            }\n            let closestSlide = null;\n            let closestDistance = null;\n            for (let i = 0; i < slidePositions.length; i++) {\n                const distance = Math.abs(slidePositions[i].slideEnd - scrolledDistance);\n                if (closestDistance === null || distance < closestDistance) {\n                    closestDistance = distance;\n                    closestSlide = slidePositions[i].slide;\n                }\n            }\n            if (closestSlide) {\n                activeSlideIdx = slides.indexOf(closestSlide);\n            }\n            else {\n                activeSlideIdx = slides.length - 1;\n            }\n        }\n        else {\n            for (let i = 0; i < slides.length; i++) {\n                const slideRect = slides[i].getBoundingClientRect();\n                const slideStart = slideRect.left - sliderRect.left + scrollLeft + getGapSize();\n                if (Math.floor(slideStart) >= Math.floor(scrollLeft)) {\n                    activeSlideIdx = i;\n                    break;\n                }\n                if (i === slides.length - 1) {\n                    scrolledPastLastSlide = true;\n                }\n            }\n        }\n        if (scrolledPastLastSlide) {\n            activeSlideIdx = slides.length - 1;\n        }\n        const oldActiveSlideIdx = slider.activeSlideIdx;\n        slider.activeSlideIdx = activeSlideIdx;\n        if (oldActiveSlideIdx !== activeSlideIdx) {\n            slider.emit('activeSlideChanged');\n        }\n    }\n    function moveToSlide(idx) {\n        const slide = slider.slides[idx];\n        if (slide) {\n            ensureSlideIsInView(slide);\n        }\n    }\n    ;\n    function canMoveToSlide(idx) {\n        if (idx < 0 || idx >= slider.slides.length) {\n            return false;\n        }\n        if (idx === slider.activeSlideIdx) {\n            return false;\n        }\n        const direction = slider.options.rtl ? (idx < slider.activeSlideIdx ? 'backwards' : 'forwards') : (idx < slider.activeSlideIdx ? 'backwards' : 'forwards');\n        // check if the slide is already in view\n        const sliderRect = slider.container.getBoundingClientRect();\n        const scrollLeft = slider.getScrollLeft();\n        const containerWidth = slider.details.containerWidth;\n        const hasUpcomingContent = slider.slides.some((s, i) => {\n            if (i === slider.activeSlideIdx) {\n                return false; // skip the slide we are checking\n            }\n            const sRect = s.getBoundingClientRect();\n            const sStart = sRect.left - sliderRect.left + scrollLeft;\n            const sEnd = sStart + sRect.width;\n            if (slider.options.rtl) {\n                if (scrollLeft === 0 && slider.details.hasOverflow) {\n                    return true;\n                }\n                return (direction === 'forwards' && i > slider.activeSlideIdx && Math.floor(sStart) < Math.floor(scrollLeft)) ||\n                    (direction === 'backwards' && i < slider.activeSlideIdx && Math.floor(sEnd) > Math.floor(scrollLeft + containerWidth));\n            }\n            else {\n                return (direction === 'forwards' && i > slider.activeSlideIdx && Math.floor(sEnd) > Math.floor(scrollLeft + containerWidth)) ||\n                    (direction === 'backwards' && i < slider.activeSlideIdx && Math.floor(sStart) < Math.floor(scrollLeft));\n            }\n        });\n        return hasUpcomingContent;\n    }\n    function moveToSlideInDirection(direction) {\n        const activeSlideIdx = slider.activeSlideIdx;\n        if (direction === 'prev') {\n            if (activeSlideIdx > 0) {\n                moveToSlide(activeSlideIdx - 1);\n            }\n        }\n        else if (direction === 'next') {\n            if (activeSlideIdx < slider.slides.length - 1) {\n                moveToSlide(activeSlideIdx + 1);\n            }\n        }\n    }\n    function getInclusiveScrollWidth() {\n        return slider.container.scrollWidth + getOutermostChildrenEdgeMarginSum(slider.container);\n    }\n    ;\n    function getInclusiveClientWidth() {\n        return slider.container.clientWidth + getOutermostChildrenEdgeMarginSum(slider.container);\n    }\n    function getScrollLeft() {\n        return slider.options.rtl ? Math.abs(slider.container.scrollLeft) : slider.container.scrollLeft;\n    }\n    ;\n    function setScrollLeft(value) {\n        slider.container.scrollLeft = slider.options.rtl ? -value : value;\n    }\n    ;\n    function getGapSize() {\n        let gapSize = 0;\n        if (slider.slides.length > 1) {\n            const firstSlideRect = slider.slides[0].getBoundingClientRect();\n            const secondSlideRect = slider.slides[1].getBoundingClientRect();\n            gapSize = slider.options.rtl ? Math.abs(Math.floor(secondSlideRect.right - firstSlideRect.left)) : Math.floor(secondSlideRect.left - firstSlideRect.right);\n        }\n        return gapSize;\n    }\n    ;\n    function getLeftOffset() {\n        let offset = 0;\n        const fullWidthOffset = slider.container.getAttribute('data-full-width-offset');\n        if (fullWidthOffset) {\n            offset = parseInt(fullWidthOffset);\n        }\n        return Math.floor(offset);\n    }\n    ;\n    function moveToDirection(direction = \"prev\") {\n        const scrollStrategy = slider.options.scrollStrategy;\n        const scrollLeft = slider.container.scrollLeft;\n        const sliderRect = slider.container.getBoundingClientRect();\n        const containerWidth = slider.container.offsetWidth;\n        let targetScrollPosition = scrollLeft;\n        const realDirection = slider.options.rtl ? (direction === 'prev' ? 'next' : 'prev') : direction;\n        if (realDirection === 'prev') {\n            targetScrollPosition = Math.max(0, scrollLeft - slider.container.offsetWidth);\n        }\n        else if (realDirection === 'next') {\n            targetScrollPosition = Math.min(slider.getInclusiveScrollWidth(), scrollLeft + slider.container.offsetWidth);\n        }\n        if (scrollStrategy === 'fullSlide') {\n            let fullSlideTargetScrollPosition = null;\n            // extend targetScrollPosition to include gap\n            if (realDirection === 'prev') {\n                fullSlideTargetScrollPosition = Math.max(0, targetScrollPosition - getGapSize());\n            }\n            else {\n                fullSlideTargetScrollPosition = Math.min(slider.getInclusiveScrollWidth(), targetScrollPosition + getGapSize());\n            }\n            if (realDirection === 'next') {\n                let partialSlideFound = false;\n                for (let slide of slider.slides) {\n                    const slideRect = slide.getBoundingClientRect();\n                    const slideStart = slideRect.left - sliderRect.left + scrollLeft;\n                    const slideEnd = slideStart + slideRect.width;\n                    if (Math.floor(slideStart) < Math.floor(targetScrollPosition) && Math.floor(slideEnd) > Math.floor(targetScrollPosition)) {\n                        fullSlideTargetScrollPosition = slideStart;\n                        partialSlideFound = true;\n                        break;\n                    }\n                }\n                if (!partialSlideFound) {\n                    fullSlideTargetScrollPosition = Math.min(targetScrollPosition, slider.getInclusiveScrollWidth() - slider.container.offsetWidth);\n                }\n                if (fullSlideTargetScrollPosition) {\n                    if (Math.floor(fullSlideTargetScrollPosition) > Math.floor(scrollLeft)) {\n                        // make sure fullSlideTargetScrollPosition is possible considering the container width\n                        const maxScrollPosition = Math.floor(slider.getInclusiveScrollWidth()) - Math.floor(containerWidth);\n                        targetScrollPosition = Math.min(fullSlideTargetScrollPosition, maxScrollPosition);\n                    }\n                    else {\n                        // cannot snap to slide, move one page worth of distance\n                        targetScrollPosition = Math.min(slider.getInclusiveScrollWidth(), scrollLeft + containerWidth);\n                    }\n                }\n            }\n            else {\n                let partialSlideFound = false;\n                for (let slide of slider.slides) {\n                    const slideRect = slide.getBoundingClientRect();\n                    const slideStart = slideRect.left - sliderRect.left + scrollLeft;\n                    const slideEnd = slideStart + slideRect.width;\n                    if (Math.floor(slideStart) < Math.floor(scrollLeft) && Math.floor(slideEnd) > Math.floor(scrollLeft)) {\n                        fullSlideTargetScrollPosition = slideEnd - containerWidth;\n                        partialSlideFound = true;\n                        break;\n                    }\n                }\n                if (!partialSlideFound) {\n                    fullSlideTargetScrollPosition = Math.max(0, scrollLeft - containerWidth);\n                }\n                if (fullSlideTargetScrollPosition && Math.floor(fullSlideTargetScrollPosition) < Math.floor(scrollLeft)) {\n                    targetScrollPosition = fullSlideTargetScrollPosition;\n                }\n            }\n        }\n        // add left offset\n        const offsettedTargetScrollPosition = targetScrollPosition - getLeftOffset();\n        if (Math.floor(offsettedTargetScrollPosition) >= 0) {\n            targetScrollPosition = offsettedTargetScrollPosition;\n        }\n        slider.emit('programmaticScrollStart');\n        slider.container.style.scrollBehavior = slider.options.scrollBehavior;\n        slider.container.scrollLeft = targetScrollPosition;\n        setTimeout(() => slider.container.style.scrollBehavior = '', 50);\n    }\n    ;\n    function snapToClosestSlide(direction = \"prev\") {\n        var _a, _b;\n        const { slides, options, container } = slider;\n        const { rtl, emulateScrollSnapMaxThreshold = 10, scrollBehavior = 'smooth', } = options;\n        const isForward = rtl ? direction === 'prev' : direction === 'next';\n        const scrollPos = getScrollLeft();\n        // Get container rect once (includes any CSS transforms)\n        const containerRect = container.getBoundingClientRect();\n        const factor = rtl ? -1 : 1;\n        // Calculate target area offset if targetWidth is defined\n        let targetAreaOffset = 0;\n        if (typeof options.targetWidth === 'function') {\n            try {\n                const targetWidth = options.targetWidth(slider);\n                const containerWidth = containerRect.width;\n                if (Number.isFinite(targetWidth) && targetWidth > 0 && targetWidth < containerWidth) {\n                    targetAreaOffset = (containerWidth - targetWidth) / 2;\n                }\n            }\n            catch (error) {\n                // ignore errors, use default offset of 0\n            }\n        }\n        // Build slide metadata\n        const slideData = [...slides].map(slide => {\n            const { width } = slide.getBoundingClientRect();\n            const slideRect = slide.getBoundingClientRect();\n            // position relative to container's left edge\n            const relativeStart = (slideRect.left - containerRect.left) + scrollPos;\n            // Adjust trigger point to align with target area start instead of container edge\n            const alignmentPoint = relativeStart - targetAreaOffset;\n            const triggerPoint = Math.min(alignmentPoint + width / 2, alignmentPoint + emulateScrollSnapMaxThreshold);\n            return { start: relativeStart - targetAreaOffset, trigger: triggerPoint };\n        });\n        // Pick the target start based on drag direction\n        let targetStart = null;\n        if (isForward) {\n            const found = slideData.find(item => scrollPos <= item.trigger);\n            targetStart = (_a = found === null || found === void 0 ? void 0 : found.start) !== null && _a !== void 0 ? _a : null;\n        }\n        else {\n            const found = [...slideData].reverse().find(item => scrollPos >= item.trigger);\n            targetStart = (_b = found === null || found === void 0 ? void 0 : found.start) !== null && _b !== void 0 ? _b : null;\n        }\n        if (targetStart == null)\n            return;\n        // Clamp to zero and apply RTL factor\n        const finalLeft = Math.max(0, Math.floor(targetStart)) * factor;\n        container.scrollTo({ left: finalLeft, behavior: scrollBehavior });\n    }\n    function on(name, cb) {\n        if (!subs[name]) {\n            subs[name] = [];\n        }\n        subs[name].push(cb);\n    }\n    ;\n    function emit(name) {\n        var _a;\n        if (subs && subs[name]) {\n            subs[name].forEach(cb => {\n                cb(slider);\n            });\n        }\n        const optionCallBack = (_a = slider === null || slider === void 0 ? void 0 : slider.options) === null || _a === void 0 ? void 0 : _a[name];\n        // Type guard to check if the option callback is a function\n        if (typeof optionCallBack === 'function') {\n            optionCallBack(slider); // Type assertion here\n        }\n    }\n    ;\n    slider = {\n        emit,\n        moveToDirection,\n        canMoveToSlide,\n        moveToSlide,\n        moveToSlideInDirection,\n        snapToClosestSlide,\n        getInclusiveScrollWidth,\n        getInclusiveClientWidth,\n        getLeftOffset,\n        getGapSize,\n        getScrollLeft,\n        setScrollLeft,\n        setActiveSlideIdx,\n        on,\n        options,\n    };\n    init();\n    return slider;\n}\n","export default function details(slider) {\n    var _a;\n    let instance;\n    let hasOverflow = false;\n    let slideCount = 0;\n    let containerWidth = 0;\n    let containerHeight = 0;\n    let scrollableAreaWidth = 0;\n    let amountOfPages = 0;\n    let currentPage = 0;\n    if (Math.floor(slider.getInclusiveScrollWidth()) > Math.floor(slider.getInclusiveClientWidth())) {\n        hasOverflow = true;\n    }\n    slideCount = (_a = slider.slides.length) !== null && _a !== void 0 ? _a : 0;\n    containerWidth = slider.container.offsetWidth;\n    containerHeight = slider.container.offsetHeight;\n    scrollableAreaWidth = slider.getInclusiveScrollWidth();\n    amountOfPages = Math.ceil(scrollableAreaWidth / containerWidth);\n    if (Math.floor(slider.getScrollLeft()) >= 0) {\n        currentPage = Math.floor(slider.getScrollLeft() / containerWidth);\n        // Consider as last page if we're within tolerance of the maximum scroll position\n        // When FullWidthPlugin is active, account for the margin offset\n        const maxScroll = scrollableAreaWidth - containerWidth - (2 * slider.getLeftOffset());\n        if (slider.getScrollLeft() >= maxScroll - 1) {\n            currentPage = amountOfPages - 1;\n        }\n    }\n    instance = {\n        hasOverflow,\n        slideCount,\n        containerWidth,\n        containerHeight,\n        scrollableAreaWidth,\n        amountOfPages,\n        currentPage,\n    };\n    return instance;\n}\n;\n","import Slider from './slider';\nexport default function OverflowSlider(container, options, plugins) {\n    try {\n        // check that container HTML element\n        if (!(container instanceof Element)) {\n            throw new Error(`Container must be HTML element, found ${typeof container}`);\n        }\n        const defaults = {\n            cssVariableContainer: container,\n            scrollBehavior: \"smooth\",\n            scrollStrategy: \"fullSlide\",\n            slidesSelector: \":scope > *\",\n            emulateScrollSnap: false,\n            emulateScrollSnapMaxThreshold: 64,\n            rtl: false,\n        };\n        const sliderOptions = Object.assign(Object.assign({}, defaults), options);\n        // disable smooth scrolling if user prefers reduced motion\n        if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {\n            sliderOptions.scrollBehavior = \"auto\";\n        }\n        return Slider(container, sliderOptions, plugins);\n    }\n    catch (e) {\n        console.error(e);\n    }\n}\n"],"names":["generateId","prefix","i","id","document","getElementById","getOutermostChildrenEdgeMarginSum","el","children","length","firstChild","firstChildStyle","getComputedStyle","firstChildMarginLeft","parseFloat","marginLeft","lastChild","lastChildStyle","marginRight","Slider","container","options","plugins","slider","subs","setDetails","isInit","oldDetails","details","newDetails","_a","instance","hasOverflow","slideCount","containerWidth","containerHeight","scrollableAreaWidth","amountOfPages","currentPage","Math","floor","getInclusiveScrollWidth","getInclusiveClientWidth","slides","offsetWidth","offsetHeight","ceil","getScrollLeft","maxScroll","getLeftOffset","obj1","obj2","keys1","Object","keys","keys2","key","prototype","hasOwnProperty","call","objectsAreEqual","emit","setSlides","Array","from","querySelectorAll","slidesSelector","setCSSVariables","cssVariableContainer","style","setProperty","targetWidth","setDataAttributes","setAttribute","rtl","setActiveSlideIdx","sliderRect","getBoundingClientRect","scrollLeft","activeSlideIdx","scrolledPastLastSlide","scrolledDistance","slidePositions","slideRect","slideEnd","abs","left","push","slide","closestSlide","closestDistance","distance","indexOf","slideStart","getGapSize","oldActiveSlideIdx","moveToSlide","idx","scrollBehavior","behavior","width","scrollTarget","setTimeout","scrollTo","ensureSlideIsInView","gapSize","firstSlideRect","secondSlideRect","right","offset","fullWidthOffset","getAttribute","parseInt","name","forEach","cb","optionCallBack","moveToDirection","direction","scrollStrategy","targetScrollPosition","realDirection","max","min","fullSlideTargetScrollPosition","partialSlideFound","maxScrollPosition","offsettedTargetScrollPosition","canMoveToSlide","some","s","sRect","sStart","sEnd","moveToSlideInDirection","snapToClosestSlide","_b","emulateScrollSnapMaxThreshold","isForward","scrollPos","containerRect","factor","targetAreaOffset","Number","isFinite","error","slideData","map","relativeStart","alignmentPoint","triggerPoint","start","trigger","targetStart","found","find","item","reverse","finalLeft","scrollWidth","clientWidth","setScrollLeft","value","on","containerId","transition","requestId","window","cancelAnimationFrame","requestAnimationFrame","MutationObserver","observe","childList","scrollTimeout","nativeScrollTimeout","programmaticScrollTimeout","ResizeObserver","nativeScrollLeft","programmaticScrollLeft","isScrolling","isUserScrolling","isProgrammaticScrolling","addEventListener","newScrollLeft","clearTimeout","nativeScrollHandler","scrollSnapType","wasInteractedWith","passive","e","focusedElement","target","parentElement","isRtl","slideLeftOffset","slideRightOffset","focusRect","focusLeftOffset","focusRightOffset","scrollFocusedSlideIntoView","addEventListeners","plugin","removeProperty","init","Element","Error","defaults","emulateScrollSnap","sliderOptions","assign","matchMedia","matches","console"],"mappings":"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"}