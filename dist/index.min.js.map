{"version":3,"file":"index.min.js","sources":["../src/core/utils.ts","../src/core/slider.ts","../src/core/details.ts","../src/core/overflow-slider.ts"],"sourcesContent":["function generateId(prefix, i = 1) {\n    const id = `${prefix}-${i}`;\n    if (document.getElementById(id)) {\n        return generateId(prefix, i + 1);\n    }\n    return id;\n}\nfunction objectsAreEqual(obj1, obj2) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (let key of keys1) {\n        // Use `Object.prototype.hasOwnProperty.call` for better safety\n        if (!Object.prototype.hasOwnProperty.call(obj2, key) || obj1[key] !== obj2[key]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getOutermostChildrenEdgeMarginSum(el) {\n    if (el.children.length === 0) {\n        return 0;\n    }\n    // get the first child and its left margin\n    const firstChild = el.children[0];\n    const firstChildStyle = getComputedStyle(firstChild);\n    const firstChildMarginLeft = parseFloat(firstChildStyle.marginLeft);\n    // Get the last child and its right margin\n    const lastChild = el.children[el.children.length - 1];\n    const lastChildStyle = getComputedStyle(lastChild);\n    const lastChildMarginRight = parseFloat(lastChildStyle.marginRight);\n    return firstChildMarginLeft + lastChildMarginRight;\n}\nexport { generateId, objectsAreEqual, getOutermostChildrenEdgeMarginSum };\n","import details from './details';\nimport { generateId, objectsAreEqual, getOutermostChildrenEdgeMarginSum } from './utils';\nexport default function Slider(container, options, plugins) {\n    let slider;\n    let subs = {};\n    const overrideTransitions = () => {\n        slider.slides.forEach((slide) => {\n            slide.style.transition = 'none';\n        });\n    };\n    const restoreTransitions = () => {\n        slider.slides.forEach((slide) => {\n            slide.style.removeProperty('transition');\n        });\n    };\n    function init() {\n        slider.container = container;\n        // ensure container has id\n        let containerId = container.getAttribute('id');\n        if (containerId === null) {\n            containerId = generateId('overflow-slider');\n            container.setAttribute('id', containerId);\n        }\n        setSlides();\n        // CSS transitions can cause delays for calculations\n        overrideTransitions();\n        setDetails(true);\n        setActiveSlideIdx();\n        slider.on('contentsChanged', () => {\n            setSlides();\n            setDetails();\n            setActiveSlideIdx();\n        });\n        slider.on('containerSizeChanged', () => setDetails());\n        let requestId = 0;\n        const setDetailsDebounce = () => {\n            if (requestId) {\n                window.cancelAnimationFrame(requestId);\n            }\n            requestId = window.requestAnimationFrame(() => {\n                setDetails();\n                setActiveSlideIdx();\n            });\n        };\n        slider.on('scroll', setDetailsDebounce);\n        addEventListeners();\n        setDataAttributes();\n        setCSSVariables();\n        if (plugins) {\n            for (const plugin of plugins) {\n                plugin(slider);\n            }\n            // plugins may mutate layout: refresh details and derived data after they run\n            // setTimeout( () => {\n            setDetails();\n            setActiveSlideIdx();\n            setCSSVariables();\n            slider.emit('pluginsLoaded');\n            // }, 250 );\n        }\n        slider.on('detailsChanged', () => {\n            setDataAttributes();\n            setCSSVariables();\n        });\n        slider.emit('created');\n        restoreTransitions();\n        slider.container.setAttribute('data-ready', 'true');\n    }\n    ;\n    function setDetails(isInit = false) {\n        const oldDetails = slider.details;\n        const newDetails = details(slider);\n        slider.details = newDetails;\n        if (!isInit && !objectsAreEqual(oldDetails, newDetails)) {\n            slider.emit('detailsChanged');\n        }\n        else if (isInit) {\n            slider.emit('detailsChanged');\n        }\n    }\n    ;\n    function setSlides() {\n        slider.slides = Array.from(slider.container.querySelectorAll(slider.options.slidesSelector));\n    }\n    function addEventListeners() {\n        // changes to DOM\n        const observer = new MutationObserver(() => slider.emit('contentsChanged'));\n        observer.observe(slider.container, { childList: true });\n        // container size changes\n        const resizeObserver = new ResizeObserver(() => slider.emit('containerSizeChanged'));\n        resizeObserver.observe(slider.container);\n        // scroll event with debouncing\n        let scrollTimeout;\n        let nativeScrollTimeout;\n        let programmaticScrollTimeout;\n        let scrollLeft = slider.container.scrollLeft;\n        let nativeScrollLeft = slider.container.scrollLeft;\n        let programmaticScrollLeft = slider.container.scrollLeft;\n        let isScrolling = false;\n        let isUserScrolling = false;\n        let isProgrammaticScrolling = false;\n        // all types of scroll\n        slider.container.addEventListener('scroll', () => {\n            const newScrollLeft = slider.container.scrollLeft;\n            if (Math.floor(scrollLeft) !== Math.floor(newScrollLeft)) {\n                if (!isScrolling) {\n                    isScrolling = true;\n                    slider.emit('scrollStart');\n                }\n                scrollLeft = newScrollLeft;\n                clearTimeout(scrollTimeout);\n                scrollTimeout = setTimeout(() => {\n                    isScrolling = false;\n                    slider.emit('scrollEnd');\n                }, 50);\n                slider.emit('scroll');\n            }\n            // keep up nativeScrolling to take into account scroll-snap\n            if (isUserScrolling) {\n                nativeScrollHandler();\n            }\n        });\n        // user initted scroll (touchmove, mouse wheel, etc.)\n        const nativeScrollHandler = () => {\n            const newScrollLeft = slider.container.scrollLeft;\n            if (Math.floor(nativeScrollLeft) !== Math.floor(newScrollLeft) && !isProgrammaticScrolling) {\n                if (!isUserScrolling) {\n                    slider.emit('nativeScrollStart');\n                    isUserScrolling = true;\n                }\n                slider.emit('nativeScroll');\n                nativeScrollLeft = newScrollLeft;\n                clearTimeout(nativeScrollTimeout);\n                nativeScrollTimeout = setTimeout(() => {\n                    isUserScrolling = false;\n                    slider.emit('nativeScrollEnd');\n                    // update programmaticScrollLeft to match nativeScrollLeft\n                    // this prevents programmaticScroll triggering with no real change to scrollLeft\n                    programmaticScrollLeft = nativeScrollLeft;\n                }, 50);\n            }\n        };\n        slider.container.addEventListener('touchmove', nativeScrollHandler);\n        slider.container.addEventListener('mousewheel', nativeScrollHandler);\n        slider.container.addEventListener('wheel', nativeScrollHandler);\n        // programmatic scroll (scrollTo, etc.)\n        slider.on('programmaticScrollStart', () => {\n            isProgrammaticScrolling = true;\n        });\n        slider.container.addEventListener('scroll', () => {\n            const newScrollLeft = slider.container.scrollLeft;\n            if (Math.floor(programmaticScrollLeft) !== Math.floor(newScrollLeft) && !isUserScrolling && isProgrammaticScrolling) {\n                programmaticScrollLeft = newScrollLeft;\n                clearTimeout(programmaticScrollTimeout);\n                programmaticScrollTimeout = setTimeout(() => {\n                    isProgrammaticScrolling = false;\n                    slider.emit('programmaticScrollEnd');\n                    // update nativeScrollLeft to match programmaticScrollLeft\n                    // this prevents nativeScroll triggering with no real change to scrollLeft\n                    nativeScrollLeft = programmaticScrollLeft;\n                }, 50);\n                slider.emit('programmaticScroll');\n            }\n        });\n        // Fix issues on scroll snapping not working on programmatic scroll (it's not smooth)\n        // by disabling scroll snap if scrolling is programmatic\n        slider.on('programmaticScrollStart', () => {\n            slider.container.style.scrollSnapType = 'none';\n        });\n        // restore scroll snap if user scroll starts\n        slider.on('nativeScrollStart', () => {\n            slider.container.style.scrollSnapType = '';\n        });\n        // Listen for mouse down and touch start events on the document\n        // This handles both mouse clicks and touch interactions\n        let wasInteractedWith = false;\n        slider.container.addEventListener('mousedown', () => {\n            wasInteractedWith = true;\n        });\n        slider.container.addEventListener('touchstart', () => {\n            wasInteractedWith = true;\n        }, { passive: true });\n        slider.container.addEventListener('focusin', (e) => {\n            // move target parents as long as they are not the container\n            // but only if focus didn't start from mouse or touch\n            if (!wasInteractedWith) {\n                let target = e.target;\n                while (target.parentElement !== slider.container) {\n                    if (target.parentElement) {\n                        target = target.parentElement;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                ensureSlideIsInView(target, 'auto');\n            }\n            wasInteractedWith = false;\n        });\n    }\n    ;\n    function setCSSVariables() {\n        slider.options.cssVariableContainer.style.setProperty('--slider-container-height', `${slider.details.containerHeight}px`);\n        slider.options.cssVariableContainer.style.setProperty('--slider-container-width', `${slider.details.containerWidth}px`);\n        slider.options.cssVariableContainer.style.setProperty('--slider-scrollable-width', `${slider.details.scrollableAreaWidth}px`);\n        slider.options.cssVariableContainer.style.setProperty('--slider-slides-count', `${slider.details.slideCount}`);\n        slider.options.cssVariableContainer.style.setProperty('--slider-x-offset', `${getLeftOffset()}px`);\n        if (typeof slider.options.targetWidth === 'function') {\n            slider.options.cssVariableContainer.style.setProperty('--slider-container-target-width', `${slider.options.targetWidth(slider)}px`);\n        }\n    }\n    function setDataAttributes() {\n        slider.container.setAttribute('data-has-overflow', slider.details.hasOverflow ? 'true' : 'false');\n        if (slider.options.rtl) {\n            slider.container.setAttribute('dir', 'rtl');\n        }\n    }\n    function ensureSlideIsInView(slide, scrollBehavior = null) {\n        const behavior = scrollBehavior || slider.options.scrollBehavior;\n        const slideRect = slide.getBoundingClientRect();\n        const sliderRect = slider.container.getBoundingClientRect();\n        const containerWidth = slider.container.offsetWidth;\n        const scrollLeft = slider.container.scrollLeft;\n        const slideStart = slideRect.left - sliderRect.left + scrollLeft;\n        const slideEnd = slideStart + slideRect.width;\n        let scrollTarget = null;\n        if (Math.floor(slideStart) < Math.floor(scrollLeft)) {\n            scrollTarget = slideStart;\n        }\n        else if (Math.floor(slideEnd) > Math.floor(scrollLeft) + Math.floor(containerWidth)) {\n            scrollTarget = slideEnd - containerWidth;\n        }\n        else if (Math.floor(slideStart) === 0) {\n            scrollTarget = 0;\n        }\n        else {\n            scrollTarget = slideStart;\n        }\n        if (scrollTarget !== null) {\n            setTimeout((scrollTarget) => {\n                slider.emit('programmaticScrollStart');\n                slider.container.scrollTo({ left: scrollTarget, behavior: behavior });\n            }, 50, scrollTarget);\n        }\n    }\n    ;\n    function setActiveSlideIdx() {\n        const sliderRect = slider.container.getBoundingClientRect();\n        const scrollLeft = slider.getScrollLeft();\n        const slides = slider.slides;\n        let activeSlideIdx = 0;\n        let scrolledPastLastSlide = false;\n        if (slider.options.rtl) {\n            const scrolledDistance = slider.getInclusiveScrollWidth() - scrollLeft - slider.getInclusiveClientWidth();\n            const slidePositions = [];\n            for (let i = slides.length - 1; i >= 0; i--) {\n                const slideRect = slides[i].getBoundingClientRect();\n                const slideEnd = Math.abs(slideRect.left) - Math.abs(sliderRect.left) + scrolledDistance;\n                slidePositions.push({\n                    slide: slides[i],\n                    slideEnd: slideEnd,\n                });\n            }\n            let closestSlide = null;\n            let closestDistance = null;\n            for (let i = 0; i < slidePositions.length; i++) {\n                const distance = Math.abs(slidePositions[i].slideEnd - scrolledDistance);\n                if (closestDistance === null || distance < closestDistance) {\n                    closestDistance = distance;\n                    closestSlide = slidePositions[i].slide;\n                }\n            }\n            if (closestSlide) {\n                activeSlideIdx = slides.indexOf(closestSlide);\n            }\n            else {\n                activeSlideIdx = slides.length - 1;\n            }\n        }\n        else {\n            for (let i = 0; i < slides.length; i++) {\n                const slideRect = slides[i].getBoundingClientRect();\n                const slideStart = slideRect.left - sliderRect.left + scrollLeft + getGapSize();\n                if (Math.floor(slideStart) >= Math.floor(scrollLeft)) {\n                    activeSlideIdx = i;\n                    break;\n                }\n                if (i === slides.length - 1) {\n                    scrolledPastLastSlide = true;\n                }\n            }\n        }\n        if (scrolledPastLastSlide) {\n            activeSlideIdx = slides.length - 1;\n        }\n        const oldActiveSlideIdx = slider.activeSlideIdx;\n        slider.activeSlideIdx = activeSlideIdx;\n        if (oldActiveSlideIdx !== activeSlideIdx) {\n            slider.emit('activeSlideChanged');\n        }\n    }\n    function moveToSlide(idx) {\n        const slide = slider.slides[idx];\n        if (slide) {\n            ensureSlideIsInView(slide);\n        }\n    }\n    ;\n    function canMoveToSlide(idx) {\n        if (idx < 0 || idx >= slider.slides.length) {\n            return false;\n        }\n        if (idx === slider.activeSlideIdx) {\n            return false;\n        }\n        const direction = slider.options.rtl ? (idx < slider.activeSlideIdx ? 'backwards' : 'forwards') : (idx < slider.activeSlideIdx ? 'backwards' : 'forwards');\n        // check if the slide is already in view\n        const sliderRect = slider.container.getBoundingClientRect();\n        const scrollLeft = slider.getScrollLeft();\n        const containerWidth = slider.details.containerWidth;\n        const hasUpcomingContent = slider.slides.some((s, i) => {\n            if (i === slider.activeSlideIdx) {\n                return false; // skip the slide we are checking\n            }\n            const sRect = s.getBoundingClientRect();\n            const sStart = sRect.left - sliderRect.left + scrollLeft;\n            const sEnd = sStart + sRect.width;\n            if (slider.options.rtl) {\n                if (scrollLeft === 0 && slider.details.hasOverflow) {\n                    return true;\n                }\n                return (direction === 'forwards' && i > slider.activeSlideIdx && Math.floor(sStart) < Math.floor(scrollLeft)) ||\n                    (direction === 'backwards' && i < slider.activeSlideIdx && Math.floor(sEnd) > Math.floor(scrollLeft + containerWidth));\n            }\n            else {\n                return (direction === 'forwards' && i > slider.activeSlideIdx && Math.floor(sEnd) > Math.floor(scrollLeft + containerWidth)) ||\n                    (direction === 'backwards' && i < slider.activeSlideIdx && Math.floor(sStart) < Math.floor(scrollLeft));\n            }\n        });\n        return hasUpcomingContent;\n    }\n    function moveToSlideInDirection(direction) {\n        const activeSlideIdx = slider.activeSlideIdx;\n        if (direction === 'prev') {\n            if (activeSlideIdx > 0) {\n                moveToSlide(activeSlideIdx - 1);\n            }\n        }\n        else if (direction === 'next') {\n            if (activeSlideIdx < slider.slides.length - 1) {\n                moveToSlide(activeSlideIdx + 1);\n            }\n        }\n    }\n    function getInclusiveScrollWidth() {\n        return slider.container.scrollWidth + getOutermostChildrenEdgeMarginSum(slider.container);\n    }\n    ;\n    function getInclusiveClientWidth() {\n        return slider.container.clientWidth + getOutermostChildrenEdgeMarginSum(slider.container);\n    }\n    function getScrollLeft() {\n        return slider.options.rtl ? Math.abs(slider.container.scrollLeft) : slider.container.scrollLeft;\n    }\n    ;\n    function setScrollLeft(value) {\n        slider.container.scrollLeft = slider.options.rtl ? -value : value;\n    }\n    ;\n    function getGapSize() {\n        let gapSize = 0;\n        if (slider.slides.length > 1) {\n            const firstSlideRect = slider.slides[0].getBoundingClientRect();\n            const secondSlideRect = slider.slides[1].getBoundingClientRect();\n            gapSize = slider.options.rtl ? Math.abs(Math.floor(secondSlideRect.right - firstSlideRect.left)) : Math.floor(secondSlideRect.left - firstSlideRect.right);\n        }\n        return gapSize;\n    }\n    ;\n    function getLeftOffset() {\n        let offset = 0;\n        const fullWidthOffset = slider.container.getAttribute('data-full-width-offset');\n        if (fullWidthOffset) {\n            offset = parseInt(fullWidthOffset);\n        }\n        return Math.floor(offset);\n    }\n    ;\n    function moveToDirection(direction = \"prev\") {\n        const scrollStrategy = slider.options.scrollStrategy;\n        const scrollLeft = slider.container.scrollLeft;\n        const sliderRect = slider.container.getBoundingClientRect();\n        const containerWidth = slider.container.offsetWidth;\n        let targetScrollPosition = scrollLeft;\n        const realDirection = slider.options.rtl ? (direction === 'prev' ? 'next' : 'prev') : direction;\n        if (realDirection === 'prev') {\n            targetScrollPosition = Math.max(0, scrollLeft - slider.container.offsetWidth);\n        }\n        else if (realDirection === 'next') {\n            targetScrollPosition = Math.min(slider.getInclusiveScrollWidth(), scrollLeft + slider.container.offsetWidth);\n        }\n        if (scrollStrategy === 'fullSlide') {\n            let fullSlideTargetScrollPosition = null;\n            // extend targetScrollPosition to include gap\n            if (realDirection === 'prev') {\n                fullSlideTargetScrollPosition = Math.max(0, targetScrollPosition - getGapSize());\n            }\n            else {\n                fullSlideTargetScrollPosition = Math.min(slider.getInclusiveScrollWidth(), targetScrollPosition + getGapSize());\n            }\n            if (realDirection === 'next') {\n                let partialSlideFound = false;\n                for (let slide of slider.slides) {\n                    const slideRect = slide.getBoundingClientRect();\n                    const slideStart = slideRect.left - sliderRect.left + scrollLeft;\n                    const slideEnd = slideStart + slideRect.width;\n                    if (Math.floor(slideStart) < Math.floor(targetScrollPosition) && Math.floor(slideEnd) > Math.floor(targetScrollPosition)) {\n                        fullSlideTargetScrollPosition = slideStart;\n                        partialSlideFound = true;\n                        break;\n                    }\n                }\n                if (!partialSlideFound) {\n                    fullSlideTargetScrollPosition = Math.min(targetScrollPosition, slider.getInclusiveScrollWidth() - slider.container.offsetWidth);\n                }\n                if (fullSlideTargetScrollPosition) {\n                    if (Math.floor(fullSlideTargetScrollPosition) > Math.floor(scrollLeft)) {\n                        // make sure fullSlideTargetScrollPosition is possible considering the container width\n                        const maxScrollPosition = Math.floor(slider.getInclusiveScrollWidth()) - Math.floor(containerWidth);\n                        targetScrollPosition = Math.min(fullSlideTargetScrollPosition, maxScrollPosition);\n                    }\n                    else {\n                        // cannot snap to slide, move one page worth of distance\n                        targetScrollPosition = Math.min(slider.getInclusiveScrollWidth(), scrollLeft + containerWidth);\n                    }\n                }\n            }\n            else {\n                let partialSlideFound = false;\n                for (let slide of slider.slides) {\n                    const slideRect = slide.getBoundingClientRect();\n                    const slideStart = slideRect.left - sliderRect.left + scrollLeft;\n                    const slideEnd = slideStart + slideRect.width;\n                    if (Math.floor(slideStart) < Math.floor(scrollLeft) && Math.floor(slideEnd) > Math.floor(scrollLeft)) {\n                        fullSlideTargetScrollPosition = slideEnd - containerWidth;\n                        partialSlideFound = true;\n                        break;\n                    }\n                }\n                if (!partialSlideFound) {\n                    fullSlideTargetScrollPosition = Math.max(0, scrollLeft - containerWidth);\n                }\n                if (fullSlideTargetScrollPosition && Math.floor(fullSlideTargetScrollPosition) < Math.floor(scrollLeft)) {\n                    targetScrollPosition = fullSlideTargetScrollPosition;\n                }\n            }\n        }\n        // add left offset\n        const offsettedTargetScrollPosition = targetScrollPosition - getLeftOffset();\n        if (Math.floor(offsettedTargetScrollPosition) >= 0) {\n            targetScrollPosition = offsettedTargetScrollPosition;\n        }\n        slider.emit('programmaticScrollStart');\n        slider.container.style.scrollBehavior = slider.options.scrollBehavior;\n        slider.container.scrollLeft = targetScrollPosition;\n        setTimeout(() => slider.container.style.scrollBehavior = '', 50);\n    }\n    ;\n    function snapToClosestSlide(direction = \"prev\") {\n        var _a, _b;\n        const { slides, options, container } = slider;\n        const { rtl, emulateScrollSnapMaxThreshold = 10, scrollBehavior = 'smooth', } = options;\n        const isForward = rtl ? direction === 'prev' : direction === 'next';\n        const scrollPos = getScrollLeft();\n        // Get container rect once (includes any CSS transforms)\n        const containerRect = container.getBoundingClientRect();\n        const factor = rtl ? -1 : 1;\n        // Calculate target area offset if targetWidth is defined\n        let targetAreaOffset = 0;\n        if (typeof options.targetWidth === 'function') {\n            try {\n                const targetWidth = options.targetWidth(slider);\n                const containerWidth = containerRect.width;\n                if (Number.isFinite(targetWidth) && targetWidth > 0 && targetWidth < containerWidth) {\n                    targetAreaOffset = (containerWidth - targetWidth) / 2;\n                }\n            }\n            catch (error) {\n                // ignore errors, use default offset of 0\n            }\n        }\n        // Build slide metadata\n        const slideData = [...slides].map(slide => {\n            const { width } = slide.getBoundingClientRect();\n            const slideRect = slide.getBoundingClientRect();\n            // position relative to container's left edge\n            const relativeStart = (slideRect.left - containerRect.left) + scrollPos;\n            // Adjust trigger point to align with target area start instead of container edge\n            const alignmentPoint = relativeStart - targetAreaOffset;\n            const triggerPoint = Math.min(alignmentPoint + width / 2, alignmentPoint + emulateScrollSnapMaxThreshold);\n            return { start: relativeStart - targetAreaOffset, trigger: triggerPoint };\n        });\n        // Pick the target start based on drag direction\n        let targetStart = null;\n        if (isForward) {\n            const found = slideData.find(item => scrollPos <= item.trigger);\n            targetStart = (_a = found === null || found === void 0 ? void 0 : found.start) !== null && _a !== void 0 ? _a : null;\n        }\n        else {\n            const found = [...slideData].reverse().find(item => scrollPos >= item.trigger);\n            targetStart = (_b = found === null || found === void 0 ? void 0 : found.start) !== null && _b !== void 0 ? _b : null;\n        }\n        if (targetStart == null)\n            return;\n        // Clamp to zero and apply RTL factor\n        const finalLeft = Math.max(0, Math.floor(targetStart)) * factor;\n        container.scrollTo({ left: finalLeft, behavior: scrollBehavior });\n    }\n    function on(name, cb) {\n        if (!subs[name]) {\n            subs[name] = [];\n        }\n        subs[name].push(cb);\n    }\n    ;\n    function emit(name) {\n        var _a;\n        if (subs && subs[name]) {\n            subs[name].forEach(cb => {\n                cb(slider);\n            });\n        }\n        const optionCallBack = (_a = slider === null || slider === void 0 ? void 0 : slider.options) === null || _a === void 0 ? void 0 : _a[name];\n        // Type guard to check if the option callback is a function\n        if (typeof optionCallBack === 'function') {\n            optionCallBack(slider); // Type assertion here\n        }\n    }\n    ;\n    slider = {\n        emit,\n        moveToDirection,\n        canMoveToSlide,\n        moveToSlide,\n        moveToSlideInDirection,\n        snapToClosestSlide,\n        getInclusiveScrollWidth,\n        getInclusiveClientWidth,\n        getLeftOffset,\n        getGapSize,\n        getScrollLeft,\n        setScrollLeft,\n        setActiveSlideIdx,\n        on,\n        options,\n    };\n    init();\n    return slider;\n}\n","export default function details(slider) {\n    var _a;\n    let instance;\n    let hasOverflow = false;\n    let slideCount = 0;\n    let containerWidth = 0;\n    let containerHeight = 0;\n    let scrollableAreaWidth = 0;\n    let amountOfPages = 0;\n    let currentPage = 0;\n    if (Math.floor(slider.getInclusiveScrollWidth()) > Math.floor(slider.getInclusiveClientWidth())) {\n        hasOverflow = true;\n    }\n    slideCount = (_a = slider.slides.length) !== null && _a !== void 0 ? _a : 0;\n    containerWidth = slider.container.offsetWidth;\n    containerHeight = slider.container.offsetHeight;\n    scrollableAreaWidth = slider.getInclusiveScrollWidth();\n    amountOfPages = Math.ceil(scrollableAreaWidth / containerWidth);\n    if (Math.floor(slider.getScrollLeft()) >= 0) {\n        currentPage = Math.floor(slider.getScrollLeft() / containerWidth);\n        // Consider as last page if we're within tolerance of the maximum scroll position\n        // When FullWidthPlugin is active, account for the margin offset\n        const maxScroll = scrollableAreaWidth - containerWidth - (2 * slider.getLeftOffset());\n        const currentScroll = slider.getScrollLeft();\n        if (currentScroll >= maxScroll - 1) {\n            currentPage = amountOfPages - 1;\n        }\n    }\n    instance = {\n        hasOverflow,\n        slideCount,\n        containerWidth,\n        containerHeight,\n        scrollableAreaWidth,\n        amountOfPages,\n        currentPage,\n    };\n    return instance;\n}\n;\n","import Slider from './slider';\nexport default function OverflowSlider(container, options, plugins) {\n    try {\n        // check that container HTML element\n        if (!(container instanceof Element)) {\n            throw new Error(`Container must be HTML element, found ${typeof container}`);\n        }\n        const defaults = {\n            cssVariableContainer: container,\n            scrollBehavior: \"smooth\",\n            scrollStrategy: \"fullSlide\",\n            slidesSelector: \":scope > *\",\n            emulateScrollSnap: false,\n            emulateScrollSnapMaxThreshold: 64,\n            rtl: false,\n        };\n        const sliderOptions = Object.assign(Object.assign({}, defaults), options);\n        // disable smooth scrolling if user prefers reduced motion\n        if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {\n            sliderOptions.scrollBehavior = \"auto\";\n        }\n        return Slider(container, sliderOptions, plugins);\n    }\n    catch (e) {\n        console.error(e);\n    }\n}\n"],"names":["generateId","prefix","i","id","document","getElementById","getOutermostChildrenEdgeMarginSum","el","children","length","firstChild","firstChildStyle","getComputedStyle","firstChildMarginLeft","parseFloat","marginLeft","lastChild","lastChildStyle","marginRight","Slider","container","options","plugins","slider","subs","setDetails","isInit","oldDetails","details","newDetails","_a","instance","hasOverflow","slideCount","containerWidth","containerHeight","scrollableAreaWidth","amountOfPages","currentPage","Math","floor","getInclusiveScrollWidth","getInclusiveClientWidth","slides","offsetWidth","offsetHeight","ceil","getScrollLeft","maxScroll","getLeftOffset","obj1","obj2","keys1","Object","keys","keys2","key","prototype","hasOwnProperty","call","objectsAreEqual","emit","setSlides","Array","from","querySelectorAll","slidesSelector","setCSSVariables","cssVariableContainer","style","setProperty","targetWidth","setDataAttributes","setAttribute","rtl","ensureSlideIsInView","slide","scrollBehavior","behavior","slideRect","getBoundingClientRect","sliderRect","scrollLeft","slideStart","left","slideEnd","width","scrollTarget","setTimeout","scrollTo","setActiveSlideIdx","activeSlideIdx","scrolledPastLastSlide","scrolledDistance","slidePositions","abs","push","closestSlide","closestDistance","distance","indexOf","getGapSize","oldActiveSlideIdx","moveToSlide","idx","gapSize","firstSlideRect","secondSlideRect","right","offset","fullWidthOffset","getAttribute","parseInt","name","forEach","cb","optionCallBack","moveToDirection","direction","scrollStrategy","targetScrollPosition","realDirection","max","min","fullSlideTargetScrollPosition","partialSlideFound","maxScrollPosition","offsettedTargetScrollPosition","canMoveToSlide","some","s","sRect","sStart","sEnd","moveToSlideInDirection","snapToClosestSlide","_b","emulateScrollSnapMaxThreshold","isForward","scrollPos","containerRect","factor","targetAreaOffset","Number","isFinite","error","slideData","map","relativeStart","alignmentPoint","triggerPoint","start","trigger","targetStart","found","find","item","reverse","finalLeft","scrollWidth","clientWidth","setScrollLeft","value","on","containerId","transition","requestId","window","cancelAnimationFrame","requestAnimationFrame","MutationObserver","observe","childList","scrollTimeout","nativeScrollTimeout","programmaticScrollTimeout","ResizeObserver","nativeScrollLeft","programmaticScrollLeft","isScrolling","isUserScrolling","isProgrammaticScrolling","addEventListener","newScrollLeft","clearTimeout","nativeScrollHandler","scrollSnapType","wasInteractedWith","passive","e","target","parentElement","addEventListeners","plugin","removeProperty","init","Element","Error","defaults","emulateScrollSnap","sliderOptions","assign","matchMedia","matches","console"],"mappings":"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"}