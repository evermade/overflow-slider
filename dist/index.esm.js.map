{"version":3,"file":"index.esm.js","sources":["../src/core/details.ts","../src/core/utils.ts","../src/core/slider.ts","../src/core/overflow-slider.ts"],"sourcesContent":["export default function details(slider) {\n    var _a;\n    let instance;\n    let hasOverflow = false;\n    let slideCount = 0;\n    let containerWidth = 0;\n    let containerHeight = 0;\n    let scrollableAreaWidth = 0;\n    let amountOfPages = 0;\n    let currentPage = 1;\n    if (Math.floor(slider.getInclusiveScrollWidth()) > Math.floor(slider.getInclusiveClientWidth())) {\n        hasOverflow = true;\n    }\n    slideCount = (_a = slider.slides.length) !== null && _a !== void 0 ? _a : 0;\n    containerWidth = slider.container.offsetWidth;\n    containerHeight = slider.container.offsetHeight;\n    scrollableAreaWidth = slider.getInclusiveScrollWidth();\n    amountOfPages = Math.ceil(scrollableAreaWidth / containerWidth);\n    if (Math.floor(slider.getScrollLeft()) >= 0) {\n        currentPage = Math.floor(slider.getScrollLeft() / containerWidth);\n        // consider as last page if the scrollLeft + containerWidth is equal to scrollWidth\n        if (Math.floor(slider.getScrollLeft() + containerWidth) === Math.floor(scrollableAreaWidth)) {\n            currentPage = amountOfPages - 1;\n        }\n    }\n    instance = {\n        hasOverflow,\n        slideCount,\n        containerWidth,\n        containerHeight,\n        scrollableAreaWidth,\n        amountOfPages,\n        currentPage,\n    };\n    return instance;\n}\n;\n","function generateId(prefix, i = 1) {\n    const id = `${prefix}-${i}`;\n    if (document.getElementById(id)) {\n        return generateId(prefix, i + 1);\n    }\n    return id;\n}\nfunction objectsAreEqual(obj1, obj2) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (let key of keys1) {\n        // Use `Object.prototype.hasOwnProperty.call` for better safety\n        if (!Object.prototype.hasOwnProperty.call(obj2, key) || obj1[key] !== obj2[key]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getOutermostChildrenEdgeMarginSum(el) {\n    if (el.children.length === 0) {\n        return 0;\n    }\n    // get the first child and its left margin\n    const firstChild = el.children[0];\n    const firstChildStyle = getComputedStyle(firstChild);\n    const firstChildMarginLeft = parseFloat(firstChildStyle.marginLeft);\n    // Get the last child and its right margin\n    const lastChild = el.children[el.children.length - 1];\n    const lastChildStyle = getComputedStyle(lastChild);\n    const lastChildMarginRight = parseFloat(lastChildStyle.marginRight);\n    return firstChildMarginLeft + lastChildMarginRight;\n}\nexport { generateId, objectsAreEqual, getOutermostChildrenEdgeMarginSum };\n","import details from './details';\nimport { generateId, objectsAreEqual, getOutermostChildrenEdgeMarginSum } from './utils';\nexport default function Slider(container, options, plugins) {\n    let slider;\n    let subs = {};\n    function init() {\n        slider.container = container;\n        // ensure container has id\n        let containerId = container.getAttribute('id');\n        if (containerId === null) {\n            containerId = generateId('overflow-slider');\n            container.setAttribute('id', containerId);\n        }\n        setSlides();\n        setDetails(true);\n        setActiveSlideIdx();\n        slider.on('contentsChanged', () => {\n            setSlides();\n            setDetails();\n            setActiveSlideIdx();\n        });\n        slider.on('containerSizeChanged', () => setDetails());\n        let requestId = 0;\n        const setDetailsDebounce = () => {\n            if (requestId) {\n                window.cancelAnimationFrame(requestId);\n            }\n            requestId = window.requestAnimationFrame(() => {\n                setDetails();\n                setActiveSlideIdx();\n            });\n        };\n        slider.on('scroll', setDetailsDebounce);\n        addEventListeners();\n        setDataAttributes();\n        setCSSVariables();\n        if (plugins) {\n            for (const plugin of plugins) {\n                plugin(slider);\n            }\n        }\n        slider.on('detailsChanged', () => {\n            setDataAttributes();\n            setCSSVariables();\n        });\n        slider.emit('created');\n        slider.container.setAttribute('data-ready', 'true');\n    }\n    ;\n    function setDetails(isInit = false) {\n        const oldDetails = slider.details;\n        const newDetails = details(slider);\n        slider.details = newDetails;\n        if (!isInit && !objectsAreEqual(oldDetails, newDetails)) {\n            slider.emit('detailsChanged');\n        }\n        else if (isInit) {\n            slider.emit('detailsChanged');\n        }\n    }\n    ;\n    function setSlides() {\n        slider.slides = Array.from(slider.container.querySelectorAll(slider.options.slidesSelector));\n    }\n    function addEventListeners() {\n        // changes to DOM\n        const observer = new MutationObserver(() => slider.emit('contentsChanged'));\n        observer.observe(slider.container, { childList: true });\n        // container size changes\n        const resizeObserver = new ResizeObserver(() => slider.emit('containerSizeChanged'));\n        resizeObserver.observe(slider.container);\n        // scroll event with debouncing\n        let scrollTimeout;\n        let nativeScrollTimeout;\n        let programmaticScrollTimeout;\n        let scrollLeft = slider.container.scrollLeft;\n        let nativeScrollLeft = slider.container.scrollLeft;\n        let programmaticScrollLeft = slider.container.scrollLeft;\n        let isScrolling = false;\n        let isUserScrolling = false;\n        let isProgrammaticScrolling = false;\n        // all types of scroll\n        slider.container.addEventListener('scroll', () => {\n            const newScrollLeft = slider.container.scrollLeft;\n            if (Math.floor(scrollLeft) !== Math.floor(newScrollLeft)) {\n                if (!isScrolling) {\n                    isScrolling = true;\n                    slider.emit('scrollStart');\n                }\n                scrollLeft = newScrollLeft;\n                clearTimeout(scrollTimeout);\n                scrollTimeout = setTimeout(() => {\n                    isScrolling = false;\n                    slider.emit('scrollEnd');\n                }, 50);\n                slider.emit('scroll');\n            }\n            // keep up nativeScrolling to take into account scroll-snap\n            if (isUserScrolling) {\n                nativeScrollHandler();\n            }\n        });\n        // user initted scroll (touchmove, mouse wheel, etc.)\n        const nativeScrollHandler = () => {\n            const newScrollLeft = slider.container.scrollLeft;\n            if (Math.floor(nativeScrollLeft) !== Math.floor(newScrollLeft) && !isProgrammaticScrolling) {\n                if (!isUserScrolling) {\n                    slider.emit('nativeScrollStart');\n                    isUserScrolling = true;\n                }\n                slider.emit('nativeScroll');\n                nativeScrollLeft = newScrollLeft;\n                clearTimeout(nativeScrollTimeout);\n                nativeScrollTimeout = setTimeout(() => {\n                    isUserScrolling = false;\n                    slider.emit('nativeScrollEnd');\n                    // update programmaticScrollLeft to match nativeScrollLeft\n                    // this prevents programmaticScroll triggering with no real change to scrollLeft\n                    programmaticScrollLeft = nativeScrollLeft;\n                }, 50);\n            }\n        };\n        slider.container.addEventListener('touchmove', nativeScrollHandler);\n        slider.container.addEventListener('mousewheel', nativeScrollHandler);\n        slider.container.addEventListener('wheel', nativeScrollHandler);\n        // programmatic scroll (scrollTo, etc.)\n        slider.on('programmaticScrollStart', () => {\n            isProgrammaticScrolling = true;\n        });\n        slider.container.addEventListener('scroll', () => {\n            const newScrollLeft = slider.container.scrollLeft;\n            if (Math.floor(programmaticScrollLeft) !== Math.floor(newScrollLeft) && !isUserScrolling && isProgrammaticScrolling) {\n                programmaticScrollLeft = newScrollLeft;\n                clearTimeout(programmaticScrollTimeout);\n                programmaticScrollTimeout = setTimeout(() => {\n                    isProgrammaticScrolling = false;\n                    slider.emit('programmaticScrollEnd');\n                    // update nativeScrollLeft to match programmaticScrollLeft\n                    // this prevents nativeScroll triggering with no real change to scrollLeft\n                    nativeScrollLeft = programmaticScrollLeft;\n                }, 50);\n                slider.emit('programmaticScroll');\n            }\n        });\n        // Fix issues on scroll snapping not working on programmatic scroll (it's not smooth)\n        // by disabling scroll snap if scrolling is programmatic\n        slider.on('programmaticScrollStart', () => {\n            slider.container.style.scrollSnapType = 'none';\n        });\n        // restore scroll snap if user scroll starts\n        slider.on('nativeScrollStart', () => {\n            slider.container.style.scrollSnapType = '';\n        });\n        // Listen for mouse down and touch start events on the document\n        // This handles both mouse clicks and touch interactions\n        let wasInteractedWith = false;\n        slider.container.addEventListener('mousedown', () => {\n            wasInteractedWith = true;\n        });\n        slider.container.addEventListener('touchstart', () => {\n            wasInteractedWith = true;\n        }, { passive: true });\n        slider.container.addEventListener('focusin', (e) => {\n            // move target parents as long as they are not the container\n            // but only if focus didn't start from mouse or touch\n            if (!wasInteractedWith) {\n                let target = e.target;\n                while (target.parentElement !== slider.container) {\n                    if (target.parentElement) {\n                        target = target.parentElement;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                ensureSlideIsInView(target, 'auto');\n            }\n            wasInteractedWith = false;\n        });\n    }\n    ;\n    function setCSSVariables() {\n        slider.options.cssVariableContainer.style.setProperty('--slider-container-height', `${slider.details.containerHeight}px`);\n        slider.options.cssVariableContainer.style.setProperty('--slider-container-width', `${slider.details.containerWidth}px`);\n        slider.options.cssVariableContainer.style.setProperty('--slider-scrollable-width', `${slider.details.scrollableAreaWidth}px`);\n        slider.options.cssVariableContainer.style.setProperty('--slider-slides-count', `${slider.details.slideCount}`);\n        slider.options.cssVariableContainer.style.setProperty('--slider-x-offset', `${getLeftOffset()}px`);\n        if (typeof slider.options.targetWidth === 'function') {\n            slider.options.cssVariableContainer.style.setProperty('--slider-container-target-width', `${slider.options.targetWidth(slider)}px`);\n        }\n    }\n    function setDataAttributes() {\n        slider.container.setAttribute('data-has-overflow', slider.details.hasOverflow ? 'true' : 'false');\n        if (slider.options.rtl) {\n            slider.container.setAttribute('dir', 'rtl');\n        }\n    }\n    function ensureSlideIsInView(slide, scrollBehavior = null) {\n        const behavior = scrollBehavior || slider.options.scrollBehavior;\n        const slideRect = slide.getBoundingClientRect();\n        const sliderRect = slider.container.getBoundingClientRect();\n        const containerWidth = slider.container.offsetWidth;\n        const scrollLeft = slider.container.scrollLeft;\n        const slideStart = slideRect.left - sliderRect.left + scrollLeft;\n        const slideEnd = slideStart + slideRect.width;\n        let scrollTarget = null;\n        if (Math.floor(slideStart) < Math.floor(scrollLeft)) {\n            scrollTarget = slideStart;\n        }\n        else if (Math.floor(slideEnd) > Math.floor(scrollLeft) + Math.floor(containerWidth)) {\n            scrollTarget = slideEnd - containerWidth;\n        }\n        else if (Math.floor(slideStart) === 0) {\n            scrollTarget = 0;\n        }\n        else {\n            scrollTarget = slideStart;\n        }\n        if (scrollTarget !== null) {\n            setTimeout((scrollTarget) => {\n                slider.emit('programmaticScrollStart');\n                slider.container.scrollTo({ left: scrollTarget, behavior: behavior });\n            }, 50, scrollTarget);\n        }\n    }\n    ;\n    function setActiveSlideIdx() {\n        const sliderRect = slider.container.getBoundingClientRect();\n        const scrollLeft = slider.getScrollLeft();\n        const slides = slider.slides;\n        let activeSlideIdx = 0;\n        let scrolledPastLastSlide = false;\n        if (slider.options.rtl) {\n            const scrolledDistance = slider.getInclusiveScrollWidth() - scrollLeft - slider.getInclusiveClientWidth();\n            const slidePositions = [];\n            for (let i = slides.length - 1; i >= 0; i--) {\n                const slideRect = slides[i].getBoundingClientRect();\n                const slideEnd = Math.abs(slideRect.left) - Math.abs(sliderRect.left) + scrolledDistance;\n                slidePositions.push({\n                    slide: slides[i],\n                    slideEnd: slideEnd,\n                });\n            }\n            let closestSlide = null;\n            let closestDistance = null;\n            for (let i = 0; i < slidePositions.length; i++) {\n                const distance = Math.abs(slidePositions[i].slideEnd - scrolledDistance);\n                if (closestDistance === null || distance < closestDistance) {\n                    closestDistance = distance;\n                    closestSlide = slidePositions[i].slide;\n                }\n            }\n            if (closestSlide) {\n                activeSlideIdx = slides.indexOf(closestSlide);\n            }\n            else {\n                activeSlideIdx = slides.length - 1;\n            }\n        }\n        else {\n            for (let i = 0; i < slides.length; i++) {\n                const slideRect = slides[i].getBoundingClientRect();\n                const slideStart = slideRect.left - sliderRect.left + scrollLeft + getGapSize();\n                if (Math.floor(slideStart) >= Math.floor(scrollLeft)) {\n                    activeSlideIdx = i;\n                    break;\n                }\n                if (i === slides.length - 1) {\n                    scrolledPastLastSlide = true;\n                }\n            }\n        }\n        if (scrolledPastLastSlide) {\n            activeSlideIdx = slides.length - 1;\n        }\n        const oldActiveSlideIdx = slider.activeSlideIdx;\n        slider.activeSlideIdx = activeSlideIdx;\n        if (oldActiveSlideIdx !== activeSlideIdx) {\n            slider.emit('activeSlideChanged');\n        }\n    }\n    function moveToSlide(idx) {\n        const slide = slider.slides[idx];\n        if (slide) {\n            ensureSlideIsInView(slide);\n        }\n    }\n    ;\n    function canMoveToSlide(idx) {\n        if (idx < 0 || idx >= slider.slides.length) {\n            return false;\n        }\n        if (idx === slider.activeSlideIdx) {\n            return false;\n        }\n        const direction = slider.options.rtl ? (idx < slider.activeSlideIdx ? 'backwards' : 'forwards') : (idx < slider.activeSlideIdx ? 'backwards' : 'forwards');\n        // check if the slide is already in view\n        const sliderRect = slider.container.getBoundingClientRect();\n        const scrollLeft = slider.getScrollLeft();\n        const containerWidth = slider.details.containerWidth;\n        const hasUpcomingContent = slider.slides.some((s, i) => {\n            if (i === slider.activeSlideIdx) {\n                return false; // skip the slide we are checking\n            }\n            const sRect = s.getBoundingClientRect();\n            const sStart = sRect.left - sliderRect.left + scrollLeft;\n            const sEnd = sStart + sRect.width;\n            if (slider.options.rtl) {\n                if (scrollLeft === 0 && slider.details.hasOverflow) {\n                    return true;\n                }\n                return (direction === 'forwards' && i > slider.activeSlideIdx && Math.floor(sStart) < Math.floor(scrollLeft)) ||\n                    (direction === 'backwards' && i < slider.activeSlideIdx && Math.floor(sEnd) > Math.floor(scrollLeft + containerWidth));\n            }\n            else {\n                return (direction === 'forwards' && i > slider.activeSlideIdx && Math.floor(sEnd) > Math.floor(scrollLeft + containerWidth)) ||\n                    (direction === 'backwards' && i < slider.activeSlideIdx && Math.floor(sStart) < Math.floor(scrollLeft));\n            }\n        });\n        return hasUpcomingContent;\n    }\n    function moveToSlideInDirection(direction) {\n        const activeSlideIdx = slider.activeSlideIdx;\n        if (direction === 'prev') {\n            if (activeSlideIdx > 0) {\n                moveToSlide(activeSlideIdx - 1);\n            }\n        }\n        else if (direction === 'next') {\n            if (activeSlideIdx < slider.slides.length - 1) {\n                moveToSlide(activeSlideIdx + 1);\n            }\n        }\n    }\n    function getInclusiveScrollWidth() {\n        return slider.container.scrollWidth + getOutermostChildrenEdgeMarginSum(slider.container);\n    }\n    ;\n    function getInclusiveClientWidth() {\n        return slider.container.clientWidth + getOutermostChildrenEdgeMarginSum(slider.container);\n    }\n    function getScrollLeft() {\n        return slider.options.rtl ? Math.abs(slider.container.scrollLeft) : slider.container.scrollLeft;\n    }\n    ;\n    function setScrollLeft(value) {\n        slider.container.scrollLeft = slider.options.rtl ? -value : value;\n    }\n    ;\n    function getGapSize() {\n        let gapSize = 0;\n        if (slider.slides.length > 1) {\n            const firstSlideRect = slider.slides[0].getBoundingClientRect();\n            const secondSlideRect = slider.slides[1].getBoundingClientRect();\n            gapSize = slider.options.rtl ? Math.abs(Math.floor(secondSlideRect.right - firstSlideRect.left)) : Math.floor(secondSlideRect.left - firstSlideRect.right);\n        }\n        return gapSize;\n    }\n    ;\n    function getLeftOffset() {\n        let offset = 0;\n        const fullWidthOffset = slider.container.getAttribute('data-full-width-offset');\n        if (fullWidthOffset) {\n            offset = parseInt(fullWidthOffset);\n        }\n        return Math.floor(offset);\n    }\n    ;\n    function moveToDirection(direction = \"prev\") {\n        const scrollStrategy = slider.options.scrollStrategy;\n        const scrollLeft = slider.container.scrollLeft;\n        const sliderRect = slider.container.getBoundingClientRect();\n        const containerWidth = slider.container.offsetWidth;\n        let targetScrollPosition = scrollLeft;\n        const realDirection = slider.options.rtl ? (direction === 'prev' ? 'next' : 'prev') : direction;\n        if (realDirection === 'prev') {\n            targetScrollPosition = Math.max(0, scrollLeft - slider.container.offsetWidth);\n        }\n        else if (realDirection === 'next') {\n            targetScrollPosition = Math.min(slider.getInclusiveScrollWidth(), scrollLeft + slider.container.offsetWidth);\n        }\n        if (scrollStrategy === 'fullSlide') {\n            let fullSlideTargetScrollPosition = null;\n            // extend targetScrollPosition to include gap\n            if (realDirection === 'prev') {\n                fullSlideTargetScrollPosition = Math.max(0, targetScrollPosition - getGapSize());\n            }\n            else {\n                fullSlideTargetScrollPosition = Math.min(slider.getInclusiveScrollWidth(), targetScrollPosition + getGapSize());\n            }\n            if (realDirection === 'next') {\n                let partialSlideFound = false;\n                for (let slide of slider.slides) {\n                    const slideRect = slide.getBoundingClientRect();\n                    const slideStart = slideRect.left - sliderRect.left + scrollLeft;\n                    const slideEnd = slideStart + slideRect.width;\n                    if (Math.floor(slideStart) < Math.floor(targetScrollPosition) && Math.floor(slideEnd) > Math.floor(targetScrollPosition)) {\n                        fullSlideTargetScrollPosition = slideStart;\n                        partialSlideFound = true;\n                        break;\n                    }\n                }\n                if (!partialSlideFound) {\n                    fullSlideTargetScrollPosition = Math.min(targetScrollPosition, slider.getInclusiveScrollWidth() - slider.container.offsetWidth);\n                }\n                if (fullSlideTargetScrollPosition) {\n                    if (Math.floor(fullSlideTargetScrollPosition) > Math.floor(scrollLeft)) {\n                        // make sure fullSlideTargetScrollPosition is possible considering the container width\n                        const maxScrollPosition = Math.floor(slider.getInclusiveScrollWidth()) - Math.floor(containerWidth);\n                        targetScrollPosition = Math.min(fullSlideTargetScrollPosition, maxScrollPosition);\n                    }\n                    else {\n                        // cannot snap to slide, move one page worth of distance\n                        targetScrollPosition = Math.min(slider.getInclusiveScrollWidth(), scrollLeft + containerWidth);\n                    }\n                }\n            }\n            else {\n                let partialSlideFound = false;\n                for (let slide of slider.slides) {\n                    const slideRect = slide.getBoundingClientRect();\n                    const slideStart = slideRect.left - sliderRect.left + scrollLeft;\n                    const slideEnd = slideStart + slideRect.width;\n                    if (Math.floor(slideStart) < Math.floor(scrollLeft) && Math.floor(slideEnd) > Math.floor(scrollLeft)) {\n                        fullSlideTargetScrollPosition = slideEnd - containerWidth;\n                        partialSlideFound = true;\n                        break;\n                    }\n                }\n                if (!partialSlideFound) {\n                    fullSlideTargetScrollPosition = Math.max(0, scrollLeft - containerWidth);\n                }\n                if (fullSlideTargetScrollPosition && Math.floor(fullSlideTargetScrollPosition) < Math.floor(scrollLeft)) {\n                    targetScrollPosition = fullSlideTargetScrollPosition;\n                }\n            }\n        }\n        // add left offset\n        const offsettedTargetScrollPosition = targetScrollPosition - getLeftOffset();\n        if (Math.floor(offsettedTargetScrollPosition) >= 0) {\n            targetScrollPosition = offsettedTargetScrollPosition;\n        }\n        slider.emit('programmaticScrollStart');\n        slider.container.style.scrollBehavior = slider.options.scrollBehavior;\n        slider.container.scrollLeft = targetScrollPosition;\n        setTimeout(() => slider.container.style.scrollBehavior = '', 50);\n    }\n    ;\n    function snapToClosestSlide(direction = \"prev\") {\n        var _a, _b;\n        const { slides, options, container } = slider;\n        const { rtl, emulateScrollSnapMaxThreshold = 10, scrollBehavior = 'smooth', } = options;\n        const isForward = rtl ? direction === 'prev' : direction === 'next';\n        const scrollPos = getScrollLeft();\n        // Get container rect once (includes any CSS transforms)\n        const containerRect = container.getBoundingClientRect();\n        const factor = rtl ? -1 : 1;\n        // Build slide metadata\n        const slideData = [...slides].map(slide => {\n            const { width } = slide.getBoundingClientRect();\n            const slideRect = slide.getBoundingClientRect();\n            // position relative to container’s left edge\n            const relativeStart = (slideRect.left - containerRect.left) + scrollPos;\n            const triggerPoint = Math.min(relativeStart + width / 2, relativeStart + emulateScrollSnapMaxThreshold);\n            return { start: relativeStart, trigger: triggerPoint };\n        });\n        // Pick the target start based on drag direction\n        let targetStart = null;\n        if (isForward) {\n            const found = slideData.find(item => scrollPos <= item.trigger);\n            targetStart = (_a = found === null || found === void 0 ? void 0 : found.start) !== null && _a !== void 0 ? _a : null;\n        }\n        else {\n            const found = [...slideData].reverse().find(item => scrollPos >= item.trigger);\n            targetStart = (_b = found === null || found === void 0 ? void 0 : found.start) !== null && _b !== void 0 ? _b : null;\n        }\n        if (targetStart == null)\n            return;\n        // Clamp to zero and apply RTL factor\n        const finalLeft = Math.max(0, Math.floor(targetStart)) * factor;\n        container.scrollTo({ left: finalLeft, behavior: scrollBehavior });\n    }\n    function on(name, cb) {\n        if (!subs[name]) {\n            subs[name] = [];\n        }\n        subs[name].push(cb);\n    }\n    ;\n    function emit(name) {\n        var _a;\n        if (subs && subs[name]) {\n            subs[name].forEach(cb => {\n                cb(slider);\n            });\n        }\n        const optionCallBack = (_a = slider === null || slider === void 0 ? void 0 : slider.options) === null || _a === void 0 ? void 0 : _a[name];\n        // Type guard to check if the option callback is a function\n        if (typeof optionCallBack === 'function') {\n            optionCallBack(slider); // Type assertion here\n        }\n    }\n    ;\n    slider = {\n        emit,\n        moveToDirection,\n        canMoveToSlide,\n        moveToSlide,\n        moveToSlideInDirection,\n        snapToClosestSlide,\n        getInclusiveScrollWidth,\n        getInclusiveClientWidth,\n        getScrollLeft,\n        setScrollLeft,\n        setActiveSlideIdx,\n        on,\n        options,\n    };\n    init();\n    return slider;\n}\n","import Slider from './slider';\nexport default function OverflowSlider(container, options, plugins) {\n    try {\n        // check that container HTML element\n        if (!(container instanceof Element)) {\n            throw new Error(`Container must be HTML element, found ${typeof container}`);\n        }\n        const defaults = {\n            cssVariableContainer: container,\n            scrollBehavior: \"smooth\",\n            scrollStrategy: \"fullSlide\",\n            slidesSelector: \":scope > *\",\n            emulateScrollSnap: false,\n            emulateScrollSnapMaxThreshold: 64,\n            rtl: false,\n        };\n        const sliderOptions = Object.assign(Object.assign({}, defaults), options);\n        // disable smooth scrolling if user prefers reduced motion\n        if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {\n            sliderOptions.scrollBehavior = \"auto\";\n        }\n        return Slider(container, sliderOptions, plugins);\n    }\n    catch (e) {\n        console.error(e);\n    }\n}\n"],"names":[],"mappings":"AAAe,SAAS,OAAO,CAAC,MAAM,EAAE;AACxC,IAAI,IAAI,EAAE;AACV,IAAI,IAAI,QAAQ;AAChB,IAAI,IAAI,WAAW,GAAG,KAAK;AAC3B,IAAI,IAAI,UAAU,GAAG,CAAC;AACtB,IAAI,IAAI,cAAc,GAAG,CAAC;AAC1B,IAAI,IAAI,eAAe,GAAG,CAAC;AAC3B,IAAI,IAAI,mBAAmB,GAAG,CAAC;AAC/B,IAAI,IAAI,aAAa,GAAG,CAAC;AACzB,IAAI,IAAI,WAAW,GAAG,CAAC;AACvB,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,uBAAuB,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,uBAAuB,EAAE,CAAC,EAAE;AACrG,QAAQ,WAAW,GAAG,IAAI;AAC1B;AACA,IAAI,UAAU,GAAG,CAAC,EAAE,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,MAAM,IAAI,IAAI,EAAE,KAAK,MAAM,GAAG,EAAE,GAAG,CAAC;AAC/E,IAAI,cAAc,GAAG,MAAM,CAAC,SAAS,CAAC,WAAW;AACjD,IAAI,eAAe,GAAG,MAAM,CAAC,SAAS,CAAC,YAAY;AACnD,IAAI,mBAAmB,GAAG,MAAM,CAAC,uBAAuB,EAAE;AAC1D,IAAI,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,mBAAmB,GAAG,cAAc,CAAC;AACnE,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,aAAa,EAAE,CAAC,IAAI,CAAC,EAAE;AACjD,QAAQ,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,aAAa,EAAE,GAAG,cAAc,CAAC;AACzE;AACA,QAAQ,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,aAAa,EAAE,GAAG,cAAc,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,mBAAmB,CAAC,EAAE;AACrG,YAAY,WAAW,GAAG,aAAa,GAAG,CAAC;AAC3C;AACA;AACA,IAAI,QAAQ,GAAG;AACf,QAAQ,WAAW;AACnB,QAAQ,UAAU;AAClB,QAAQ,cAAc;AACtB,QAAQ,eAAe;AACvB,QAAQ,mBAAmB;AAC3B,QAAQ,aAAa;AACrB,QAAQ,WAAW;AACnB,KAAK;AACL,IAAI,OAAO,QAAQ;AACnB;;ACnCA,SAAS,UAAU,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE;AACnC,IAAI,MAAM,EAAE,GAAG,CAAC,EAAE,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AAC/B,IAAI,IAAI,QAAQ,CAAC,cAAc,CAAC,EAAE,CAAC,EAAE;AACrC,QAAQ,OAAO,UAAU,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,CAAC;AACxC;AACA,IAAI,OAAO,EAAE;AACb;AACA,SAAS,eAAe,CAAC,IAAI,EAAE,IAAI,EAAE;AACrC,IAAI,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;AACnC,IAAI,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;AACnC,IAAI,IAAI,KAAK,CAAC,MAAM,KAAK,KAAK,CAAC,MAAM,EAAE;AACvC,QAAQ,OAAO,KAAK;AACpB;AACA,IAAI,KAAK,IAAI,GAAG,IAAI,KAAK,EAAE;AAC3B;AACA,QAAQ,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE;AACzF,YAAY,OAAO,KAAK;AACxB;AACA;AACA,IAAI,OAAO,IAAI;AACf;AACA,SAAS,iCAAiC,CAAC,EAAE,EAAE;AAC/C,IAAI,IAAI,EAAE,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;AAClC,QAAQ,OAAO,CAAC;AAChB;AACA;AACA,IAAI,MAAM,UAAU,GAAG,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;AACrC,IAAI,MAAM,eAAe,GAAG,gBAAgB,CAAC,UAAU,CAAC;AACxD,IAAI,MAAM,oBAAoB,GAAG,UAAU,CAAC,eAAe,CAAC,UAAU,CAAC;AACvE;AACA,IAAI,MAAM,SAAS,GAAG,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;AACzD,IAAI,MAAM,cAAc,GAAG,gBAAgB,CAAC,SAAS,CAAC;AACtD,IAAI,MAAM,oBAAoB,GAAG,UAAU,CAAC,cAAc,CAAC,WAAW,CAAC;AACvE,IAAI,OAAO,oBAAoB,GAAG,oBAAoB;AACtD;;AChCe,SAAS,MAAM,CAAC,SAAS,EAAE,OAAO,EAAE,OAAO,EAAE;AAC5D,IAAI,IAAI,MAAM;AACd,IAAI,IAAI,IAAI,GAAG,EAAE;AACjB,IAAI,SAAS,IAAI,GAAG;AACpB,QAAQ,MAAM,CAAC,SAAS,GAAG,SAAS;AACpC;AACA,QAAQ,IAAI,WAAW,GAAG,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC;AACtD,QAAQ,IAAI,WAAW,KAAK,IAAI,EAAE;AAClC,YAAY,WAAW,GAAG,UAAU,CAAC,iBAAiB,CAAC;AACvD,YAAY,SAAS,CAAC,YAAY,CAAC,IAAI,EAAE,WAAW,CAAC;AACrD;AACA,QAAQ,SAAS,EAAE;AACnB,QAAQ,UAAU,CAAC,IAAI,CAAC;AACxB,QAAQ,iBAAiB,EAAE;AAC3B,QAAQ,MAAM,CAAC,EAAE,CAAC,iBAAiB,EAAE,MAAM;AAC3C,YAAY,SAAS,EAAE;AACvB,YAAY,UAAU,EAAE;AACxB,YAAY,iBAAiB,EAAE;AAC/B,SAAS,CAAC;AACV,QAAQ,MAAM,CAAC,EAAE,CAAC,sBAAsB,EAAE,MAAM,UAAU,EAAE,CAAC;AAC7D,QAAQ,IAAI,SAAS,GAAG,CAAC;AACzB,QAAQ,MAAM,kBAAkB,GAAG,MAAM;AACzC,YAAY,IAAI,SAAS,EAAE;AAC3B,gBAAgB,MAAM,CAAC,oBAAoB,CAAC,SAAS,CAAC;AACtD;AACA,YAAY,SAAS,GAAG,MAAM,CAAC,qBAAqB,CAAC,MAAM;AAC3D,gBAAgB,UAAU,EAAE;AAC5B,gBAAgB,iBAAiB,EAAE;AACnC,aAAa,CAAC;AACd,SAAS;AACT,QAAQ,MAAM,CAAC,EAAE,CAAC,QAAQ,EAAE,kBAAkB,CAAC;AAC/C,QAAQ,iBAAiB,EAAE;AAC3B,QAAQ,iBAAiB,EAAE;AAC3B,QAAQ,eAAe,EAAE;AACzB,QAAQ,IAAI,OAAO,EAAE;AACrB,YAAY,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;AAC1C,gBAAgB,MAAM,CAAC,MAAM,CAAC;AAC9B;AACA;AACA,QAAQ,MAAM,CAAC,EAAE,CAAC,gBAAgB,EAAE,MAAM;AAC1C,YAAY,iBAAiB,EAAE;AAC/B,YAAY,eAAe,EAAE;AAC7B,SAAS,CAAC;AACV,QAAQ,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC;AAC9B,QAAQ,MAAM,CAAC,SAAS,CAAC,YAAY,CAAC,YAAY,EAAE,MAAM,CAAC;AAC3D;AAEA,IAAI,SAAS,UAAU,CAAC,MAAM,GAAG,KAAK,EAAE;AACxC,QAAQ,MAAM,UAAU,GAAG,MAAM,CAAC,OAAO;AACzC,QAAQ,MAAM,UAAU,GAAG,OAAO,CAAC,MAAM,CAAC;AAC1C,QAAQ,MAAM,CAAC,OAAO,GAAG,UAAU;AACnC,QAAQ,IAAI,CAAC,MAAM,IAAI,CAAC,eAAe,CAAC,UAAU,EAAE,UAAU,CAAC,EAAE;AACjE,YAAY,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC;AACzC;AACA,aAAa,IAAI,MAAM,EAAE;AACzB,YAAY,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC;AACzC;AACA;AAEA,IAAI,SAAS,SAAS,GAAG;AACzB,QAAQ,MAAM,CAAC,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC,MAAM,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC;AACpG;AACA,IAAI,SAAS,iBAAiB,GAAG;AACjC;AACA,QAAQ,MAAM,QAAQ,GAAG,IAAI,gBAAgB,CAAC,MAAM,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;AACnF,QAAQ,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC;AAC/D;AACA,QAAQ,MAAM,cAAc,GAAG,IAAI,cAAc,CAAC,MAAM,MAAM,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC;AAC5F,QAAQ,cAAc,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,CAAC;AAChD;AACA,QAAQ,IAAI,aAAa;AACzB,QAAQ,IAAI,mBAAmB;AAC/B,QAAQ,IAAI,yBAAyB;AACrC,QAAQ,IAAI,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC,UAAU;AACpD,QAAQ,IAAI,gBAAgB,GAAG,MAAM,CAAC,SAAS,CAAC,UAAU;AAC1D,QAAQ,IAAI,sBAAsB,GAAG,MAAM,CAAC,SAAS,CAAC,UAAU;AAChE,QAAQ,IAAI,WAAW,GAAG,KAAK;AAC/B,QAAQ,IAAI,eAAe,GAAG,KAAK;AACnC,QAAQ,IAAI,uBAAuB,GAAG,KAAK;AAC3C;AACA,QAAQ,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC,QAAQ,EAAE,MAAM;AAC1D,YAAY,MAAM,aAAa,GAAG,MAAM,CAAC,SAAS,CAAC,UAAU;AAC7D,YAAY,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,EAAE;AACtE,gBAAgB,IAAI,CAAC,WAAW,EAAE;AAClC,oBAAoB,WAAW,GAAG,IAAI;AACtC,oBAAoB,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC;AAC9C;AACA,gBAAgB,UAAU,GAAG,aAAa;AAC1C,gBAAgB,YAAY,CAAC,aAAa,CAAC;AAC3C,gBAAgB,aAAa,GAAG,UAAU,CAAC,MAAM;AACjD,oBAAoB,WAAW,GAAG,KAAK;AACvC,oBAAoB,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC;AAC5C,iBAAiB,EAAE,EAAE,CAAC;AACtB,gBAAgB,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;AACrC;AACA;AACA,YAAY,IAAI,eAAe,EAAE;AACjC,gBAAgB,mBAAmB,EAAE;AACrC;AACA,SAAS,CAAC;AACV;AACA,QAAQ,MAAM,mBAAmB,GAAG,MAAM;AAC1C,YAAY,MAAM,aAAa,GAAG,MAAM,CAAC,SAAS,CAAC,UAAU;AAC7D,YAAY,IAAI,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,IAAI,CAAC,uBAAuB,EAAE;AACxG,gBAAgB,IAAI,CAAC,eAAe,EAAE;AACtC,oBAAoB,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC;AACpD,oBAAoB,eAAe,GAAG,IAAI;AAC1C;AACA,gBAAgB,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC;AAC3C,gBAAgB,gBAAgB,GAAG,aAAa;AAChD,gBAAgB,YAAY,CAAC,mBAAmB,CAAC;AACjD,gBAAgB,mBAAmB,GAAG,UAAU,CAAC,MAAM;AACvD,oBAAoB,eAAe,GAAG,KAAK;AAC3C,oBAAoB,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC;AAClD;AACA;AACA,oBAAoB,sBAAsB,GAAG,gBAAgB;AAC7D,iBAAiB,EAAE,EAAE,CAAC;AACtB;AACA,SAAS;AACT,QAAQ,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC,WAAW,EAAE,mBAAmB,CAAC;AAC3E,QAAQ,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC,YAAY,EAAE,mBAAmB,CAAC;AAC5E,QAAQ,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC,OAAO,EAAE,mBAAmB,CAAC;AACvE;AACA,QAAQ,MAAM,CAAC,EAAE,CAAC,yBAAyB,EAAE,MAAM;AACnD,YAAY,uBAAuB,GAAG,IAAI;AAC1C,SAAS,CAAC;AACV,QAAQ,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC,QAAQ,EAAE,MAAM;AAC1D,YAAY,MAAM,aAAa,GAAG,MAAM,CAAC,SAAS,CAAC,UAAU;AAC7D,YAAY,IAAI,IAAI,CAAC,KAAK,CAAC,sBAAsB,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,IAAI,CAAC,eAAe,IAAI,uBAAuB,EAAE;AACjI,gBAAgB,sBAAsB,GAAG,aAAa;AACtD,gBAAgB,YAAY,CAAC,yBAAyB,CAAC;AACvD,gBAAgB,yBAAyB,GAAG,UAAU,CAAC,MAAM;AAC7D,oBAAoB,uBAAuB,GAAG,KAAK;AACnD,oBAAoB,MAAM,CAAC,IAAI,CAAC,uBAAuB,CAAC;AACxD;AACA;AACA,oBAAoB,gBAAgB,GAAG,sBAAsB;AAC7D,iBAAiB,EAAE,EAAE,CAAC;AACtB,gBAAgB,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC;AACjD;AACA,SAAS,CAAC;AACV;AACA;AACA,QAAQ,MAAM,CAAC,EAAE,CAAC,yBAAyB,EAAE,MAAM;AACnD,YAAY,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,cAAc,GAAG,MAAM;AAC1D,SAAS,CAAC;AACV;AACA,QAAQ,MAAM,CAAC,EAAE,CAAC,mBAAmB,EAAE,MAAM;AAC7C,YAAY,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,cAAc,GAAG,EAAE;AACtD,SAAS,CAAC;AACV;AACA;AACA,QAAQ,IAAI,iBAAiB,GAAG,KAAK;AACrC,QAAQ,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC,WAAW,EAAE,MAAM;AAC7D,YAAY,iBAAiB,GAAG,IAAI;AACpC,SAAS,CAAC;AACV,QAAQ,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC,YAAY,EAAE,MAAM;AAC9D,YAAY,iBAAiB,GAAG,IAAI;AACpC,SAAS,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;AAC7B,QAAQ,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC,SAAS,EAAE,CAAC,CAAC,KAAK;AAC5D;AACA;AACA,YAAY,IAAI,CAAC,iBAAiB,EAAE;AACpC,gBAAgB,IAAI,MAAM,GAAG,CAAC,CAAC,MAAM;AACrC,gBAAgB,OAAO,MAAM,CAAC,aAAa,KAAK,MAAM,CAAC,SAAS,EAAE;AAClE,oBAAoB,IAAI,MAAM,CAAC,aAAa,EAAE;AAC9C,wBAAwB,MAAM,GAAG,MAAM,CAAC,aAAa;AACrD;AACA,yBAAyB;AACzB,wBAAwB;AACxB;AACA;AACA,gBAAgB,mBAAmB,CAAC,MAAM,EAAE,MAAM,CAAC;AACnD;AACA,YAAY,iBAAiB,GAAG,KAAK;AACrC,SAAS,CAAC;AACV;AAEA,IAAI,SAAS,eAAe,GAAG;AAC/B,QAAQ,MAAM,CAAC,OAAO,CAAC,oBAAoB,CAAC,KAAK,CAAC,WAAW,CAAC,2BAA2B,EAAE,CAAC,EAAE,MAAM,CAAC,OAAO,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC;AACjI,QAAQ,MAAM,CAAC,OAAO,CAAC,oBAAoB,CAAC,KAAK,CAAC,WAAW,CAAC,0BAA0B,EAAE,CAAC,EAAE,MAAM,CAAC,OAAO,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC;AAC/H,QAAQ,MAAM,CAAC,OAAO,CAAC,oBAAoB,CAAC,KAAK,CAAC,WAAW,CAAC,2BAA2B,EAAE,CAAC,EAAE,MAAM,CAAC,OAAO,CAAC,mBAAmB,CAAC,EAAE,CAAC,CAAC;AACrI,QAAQ,MAAM,CAAC,OAAO,CAAC,oBAAoB,CAAC,KAAK,CAAC,WAAW,CAAC,uBAAuB,EAAE,CAAC,EAAE,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC;AACtH,QAAQ,MAAM,CAAC,OAAO,CAAC,oBAAoB,CAAC,KAAK,CAAC,WAAW,CAAC,mBAAmB,EAAE,CAAC,EAAE,aAAa,EAAE,CAAC,EAAE,CAAC,CAAC;AAC1G,QAAQ,IAAI,OAAO,MAAM,CAAC,OAAO,CAAC,WAAW,KAAK,UAAU,EAAE;AAC9D,YAAY,MAAM,CAAC,OAAO,CAAC,oBAAoB,CAAC,KAAK,CAAC,WAAW,CAAC,iCAAiC,EAAE,CAAC,EAAE,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;AAC/I;AACA;AACA,IAAI,SAAS,iBAAiB,GAAG;AACjC,QAAQ,MAAM,CAAC,SAAS,CAAC,YAAY,CAAC,mBAAmB,EAAE,MAAM,CAAC,OAAO,CAAC,WAAW,GAAG,MAAM,GAAG,OAAO,CAAC;AACzG,QAAQ,IAAI,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE;AAChC,YAAY,MAAM,CAAC,SAAS,CAAC,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC;AACvD;AACA;AACA,IAAI,SAAS,mBAAmB,CAAC,KAAK,EAAE,cAAc,GAAG,IAAI,EAAE;AAC/D,QAAQ,MAAM,QAAQ,GAAG,cAAc,IAAI,MAAM,CAAC,OAAO,CAAC,cAAc;AACxE,QAAQ,MAAM,SAAS,GAAG,KAAK,CAAC,qBAAqB,EAAE;AACvD,QAAQ,MAAM,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC,qBAAqB,EAAE;AACnE,QAAQ,MAAM,cAAc,GAAG,MAAM,CAAC,SAAS,CAAC,WAAW;AAC3D,QAAQ,MAAM,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC,UAAU;AACtD,QAAQ,MAAM,UAAU,GAAG,SAAS,CAAC,IAAI,GAAG,UAAU,CAAC,IAAI,GAAG,UAAU;AACxE,QAAQ,MAAM,QAAQ,GAAG,UAAU,GAAG,SAAS,CAAC,KAAK;AACrD,QAAQ,IAAI,YAAY,GAAG,IAAI;AAC/B,QAAQ,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE;AAC7D,YAAY,YAAY,GAAG,UAAU;AACrC;AACA,aAAa,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,EAAE;AAC7F,YAAY,YAAY,GAAG,QAAQ,GAAG,cAAc;AACpD;AACA,aAAa,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;AAC/C,YAAY,YAAY,GAAG,CAAC;AAC5B;AACA,aAAa;AACb,YAAY,YAAY,GAAG,UAAU;AACrC;AACA,QAAQ,IAAI,YAAY,KAAK,IAAI,EAAE;AACnC,YAAY,UAAU,CAAC,CAAC,YAAY,KAAK;AACzC,gBAAgB,MAAM,CAAC,IAAI,CAAC,yBAAyB,CAAC;AACtD,gBAAgB,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,EAAE,IAAI,EAAE,YAAY,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC;AACrF,aAAa,EAAE,EAAE,EAAE,YAAY,CAAC;AAChC;AACA;AAEA,IAAI,SAAS,iBAAiB,GAAG;AACjC,QAAQ,MAAM,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC,qBAAqB,EAAE;AACnE,QAAQ,MAAM,UAAU,GAAG,MAAM,CAAC,aAAa,EAAE;AACjD,QAAQ,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM;AACpC,QAAQ,IAAI,cAAc,GAAG,CAAC;AAC9B,QAAQ,IAAI,qBAAqB,GAAG,KAAK;AACzC,QAAQ,IAAI,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE;AAChC,YAAY,MAAM,gBAAgB,GAAG,MAAM,CAAC,uBAAuB,EAAE,GAAG,UAAU,GAAG,MAAM,CAAC,uBAAuB,EAAE;AACrH,YAAY,MAAM,cAAc,GAAG,EAAE;AACrC,YAAY,KAAK,IAAI,CAAC,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;AACzD,gBAAgB,MAAM,SAAS,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,qBAAqB,EAAE;AACnE,gBAAgB,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,gBAAgB;AACxG,gBAAgB,cAAc,CAAC,IAAI,CAAC;AACpC,oBAAoB,KAAK,EAAE,MAAM,CAAC,CAAC,CAAC;AACpC,oBAAoB,QAAQ,EAAE,QAAQ;AACtC,iBAAiB,CAAC;AAClB;AACA,YAAY,IAAI,YAAY,GAAG,IAAI;AACnC,YAAY,IAAI,eAAe,GAAG,IAAI;AACtC,YAAY,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC5D,gBAAgB,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,QAAQ,GAAG,gBAAgB,CAAC;AACxF,gBAAgB,IAAI,eAAe,KAAK,IAAI,IAAI,QAAQ,GAAG,eAAe,EAAE;AAC5E,oBAAoB,eAAe,GAAG,QAAQ;AAC9C,oBAAoB,YAAY,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC,KAAK;AAC1D;AACA;AACA,YAAY,IAAI,YAAY,EAAE;AAC9B,gBAAgB,cAAc,GAAG,MAAM,CAAC,OAAO,CAAC,YAAY,CAAC;AAC7D;AACA,iBAAiB;AACjB,gBAAgB,cAAc,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC;AAClD;AACA;AACA,aAAa;AACb,YAAY,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACpD,gBAAgB,MAAM,SAAS,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,qBAAqB,EAAE;AACnE,gBAAgB,MAAM,UAAU,GAAG,SAAS,CAAC,IAAI,GAAG,UAAU,CAAC,IAAI,GAAG,UAAU,GAAG,UAAU,EAAE;AAC/F,gBAAgB,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE;AACtE,oBAAoB,cAAc,GAAG,CAAC;AACtC,oBAAoB;AACpB;AACA,gBAAgB,IAAI,CAAC,KAAK,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;AAC7C,oBAAoB,qBAAqB,GAAG,IAAI;AAChD;AACA;AACA;AACA,QAAQ,IAAI,qBAAqB,EAAE;AACnC,YAAY,cAAc,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC;AAC9C;AACA,QAAQ,MAAM,iBAAiB,GAAG,MAAM,CAAC,cAAc;AACvD,QAAQ,MAAM,CAAC,cAAc,GAAG,cAAc;AAC9C,QAAQ,IAAI,iBAAiB,KAAK,cAAc,EAAE;AAClD,YAAY,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC;AAC7C;AACA;AACA,IAAI,SAAS,WAAW,CAAC,GAAG,EAAE;AAC9B,QAAQ,MAAM,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC;AACxC,QAAQ,IAAI,KAAK,EAAE;AACnB,YAAY,mBAAmB,CAAC,KAAK,CAAC;AACtC;AACA;AAEA,IAAI,SAAS,cAAc,CAAC,GAAG,EAAE;AACjC,QAAQ,IAAI,GAAG,GAAG,CAAC,IAAI,GAAG,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE;AACpD,YAAY,OAAO,KAAK;AACxB;AACA,QAAQ,IAAI,GAAG,KAAK,MAAM,CAAC,cAAc,EAAE;AAC3C,YAAY,OAAO,KAAK;AACxB;AACA,QAAQ,MAAM,SAAS,GAAG,MAAM,CAAC,OAAO,CAAC,GAAG,IAAI,GAAG,GAAG,MAAM,CAAC,cAAc,GAAG,WAAW,GAAG,UAAU,KAAK,GAAG,GAAG,MAAM,CAAC,cAAc,GAAG,WAAW,GAAG,UAAU,CAAC;AAClK;AACA,QAAQ,MAAM,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC,qBAAqB,EAAE;AACnE,QAAQ,MAAM,UAAU,GAAG,MAAM,CAAC,aAAa,EAAE;AACjD,QAAQ,MAAM,cAAc,GAAG,MAAM,CAAC,OAAO,CAAC,cAAc;AAC5D,QAAQ,MAAM,kBAAkB,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK;AAChE,YAAY,IAAI,CAAC,KAAK,MAAM,CAAC,cAAc,EAAE;AAC7C,gBAAgB,OAAO,KAAK,CAAC;AAC7B;AACA,YAAY,MAAM,KAAK,GAAG,CAAC,CAAC,qBAAqB,EAAE;AACnD,YAAY,MAAM,MAAM,GAAG,KAAK,CAAC,IAAI,GAAG,UAAU,CAAC,IAAI,GAAG,UAAU;AACpE,YAAY,MAAM,IAAI,GAAG,MAAM,GAAG,KAAK,CAAC,KAAK;AAC7C,YAAY,IAAI,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE;AACpC,gBAAgB,IAAI,UAAU,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,WAAW,EAAE;AACpE,oBAAoB,OAAO,IAAI;AAC/B;AACA,gBAAgB,OAAO,CAAC,SAAS,KAAK,UAAU,IAAI,CAAC,GAAG,MAAM,CAAC,cAAc,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC;AAC5H,qBAAqB,SAAS,KAAK,WAAW,IAAI,CAAC,GAAG,MAAM,CAAC,cAAc,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,GAAG,cAAc,CAAC,CAAC;AAC1I;AACA,iBAAiB;AACjB,gBAAgB,OAAO,CAAC,SAAS,KAAK,UAAU,IAAI,CAAC,GAAG,MAAM,CAAC,cAAc,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,GAAG,cAAc,CAAC;AAC3I,qBAAqB,SAAS,KAAK,WAAW,IAAI,CAAC,GAAG,MAAM,CAAC,cAAc,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;AAC3H;AACA,SAAS,CAAC;AACV,QAAQ,OAAO,kBAAkB;AACjC;AACA,IAAI,SAAS,sBAAsB,CAAC,SAAS,EAAE;AAC/C,QAAQ,MAAM,cAAc,GAAG,MAAM,CAAC,cAAc;AACpD,QAAQ,IAAI,SAAS,KAAK,MAAM,EAAE;AAClC,YAAY,IAAI,cAAc,GAAG,CAAC,EAAE;AACpC,gBAAgB,WAAW,CAAC,cAAc,GAAG,CAAC,CAAC;AAC/C;AACA;AACA,aAAa,IAAI,SAAS,KAAK,MAAM,EAAE;AACvC,YAAY,IAAI,cAAc,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;AAC3D,gBAAgB,WAAW,CAAC,cAAc,GAAG,CAAC,CAAC;AAC/C;AACA;AACA;AACA,IAAI,SAAS,uBAAuB,GAAG;AACvC,QAAQ,OAAO,MAAM,CAAC,SAAS,CAAC,WAAW,GAAG,iCAAiC,CAAC,MAAM,CAAC,SAAS,CAAC;AACjG;AAEA,IAAI,SAAS,uBAAuB,GAAG;AACvC,QAAQ,OAAO,MAAM,CAAC,SAAS,CAAC,WAAW,GAAG,iCAAiC,CAAC,MAAM,CAAC,SAAS,CAAC;AACjG;AACA,IAAI,SAAS,aAAa,GAAG;AAC7B,QAAQ,OAAO,MAAM,CAAC,OAAO,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC,GAAG,MAAM,CAAC,SAAS,CAAC,UAAU;AACvG;AAEA,IAAI,SAAS,aAAa,CAAC,KAAK,EAAE;AAClC,QAAQ,MAAM,CAAC,SAAS,CAAC,UAAU,GAAG,MAAM,CAAC,OAAO,CAAC,GAAG,GAAG,CAAC,KAAK,GAAG,KAAK;AACzE;AAEA,IAAI,SAAS,UAAU,GAAG;AAC1B,QAAQ,IAAI,OAAO,GAAG,CAAC;AACvB,QAAQ,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;AACtC,YAAY,MAAM,cAAc,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,qBAAqB,EAAE;AAC3E,YAAY,MAAM,eAAe,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,qBAAqB,EAAE;AAC5E,YAAY,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,KAAK,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,IAAI,GAAG,cAAc,CAAC,KAAK,CAAC;AACtK;AACA,QAAQ,OAAO,OAAO;AACtB;AAEA,IAAI,SAAS,aAAa,GAAG;AAC7B,QAAQ,IAAI,MAAM,GAAG,CAAC;AACtB,QAAQ,MAAM,eAAe,GAAG,MAAM,CAAC,SAAS,CAAC,YAAY,CAAC,wBAAwB,CAAC;AACvF,QAAQ,IAAI,eAAe,EAAE;AAC7B,YAAY,MAAM,GAAG,QAAQ,CAAC,eAAe,CAAC;AAC9C;AACA,QAAQ,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;AACjC;AAEA,IAAI,SAAS,eAAe,CAAC,SAAS,GAAG,MAAM,EAAE;AACjD,QAAQ,MAAM,cAAc,GAAG,MAAM,CAAC,OAAO,CAAC,cAAc;AAC5D,QAAQ,MAAM,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC,UAAU;AACtD,QAAQ,MAAM,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC,qBAAqB,EAAE;AACnE,QAAQ,MAAM,cAAc,GAAG,MAAM,CAAC,SAAS,CAAC,WAAW;AAC3D,QAAQ,IAAI,oBAAoB,GAAG,UAAU;AAC7C,QAAQ,MAAM,aAAa,GAAG,MAAM,CAAC,OAAO,CAAC,GAAG,IAAI,SAAS,KAAK,MAAM,GAAG,MAAM,GAAG,MAAM,IAAI,SAAS;AACvG,QAAQ,IAAI,aAAa,KAAK,MAAM,EAAE;AACtC,YAAY,oBAAoB,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC,WAAW,CAAC;AACzF;AACA,aAAa,IAAI,aAAa,KAAK,MAAM,EAAE;AAC3C,YAAY,oBAAoB,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,uBAAuB,EAAE,EAAE,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC,WAAW,CAAC;AACxH;AACA,QAAQ,IAAI,cAAc,KAAK,WAAW,EAAE;AAC5C,YAAY,IAAI,6BAA6B,GAAG,IAAI;AACpD;AACA,YAAY,IAAI,aAAa,KAAK,MAAM,EAAE;AAC1C,gBAAgB,6BAA6B,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,oBAAoB,GAAG,UAAU,EAAE,CAAC;AAChG;AACA,iBAAiB;AACjB,gBAAgB,6BAA6B,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,uBAAuB,EAAE,EAAE,oBAAoB,GAAG,UAAU,EAAE,CAAC;AAC/H;AACA,YAAY,IAAI,aAAa,KAAK,MAAM,EAAE;AAC1C,gBAAgB,IAAI,iBAAiB,GAAG,KAAK;AAC7C,gBAAgB,KAAK,IAAI,KAAK,IAAI,MAAM,CAAC,MAAM,EAAE;AACjD,oBAAoB,MAAM,SAAS,GAAG,KAAK,CAAC,qBAAqB,EAAE;AACnE,oBAAoB,MAAM,UAAU,GAAG,SAAS,CAAC,IAAI,GAAG,UAAU,CAAC,IAAI,GAAG,UAAU;AACpF,oBAAoB,MAAM,QAAQ,GAAG,UAAU,GAAG,SAAS,CAAC,KAAK;AACjE,oBAAoB,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,oBAAoB,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,oBAAoB,CAAC,EAAE;AAC9I,wBAAwB,6BAA6B,GAAG,UAAU;AAClE,wBAAwB,iBAAiB,GAAG,IAAI;AAChD,wBAAwB;AACxB;AACA;AACA,gBAAgB,IAAI,CAAC,iBAAiB,EAAE;AACxC,oBAAoB,6BAA6B,GAAG,IAAI,CAAC,GAAG,CAAC,oBAAoB,EAAE,MAAM,CAAC,uBAAuB,EAAE,GAAG,MAAM,CAAC,SAAS,CAAC,WAAW,CAAC;AACnJ;AACA,gBAAgB,IAAI,6BAA6B,EAAE;AACnD,oBAAoB,IAAI,IAAI,CAAC,KAAK,CAAC,6BAA6B,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE;AAC5F;AACA,wBAAwB,MAAM,iBAAiB,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,uBAAuB,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC;AAC3H,wBAAwB,oBAAoB,GAAG,IAAI,CAAC,GAAG,CAAC,6BAA6B,EAAE,iBAAiB,CAAC;AACzG;AACA,yBAAyB;AACzB;AACA,wBAAwB,oBAAoB,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,uBAAuB,EAAE,EAAE,UAAU,GAAG,cAAc,CAAC;AACtH;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,IAAI,iBAAiB,GAAG,KAAK;AAC7C,gBAAgB,KAAK,IAAI,KAAK,IAAI,MAAM,CAAC,MAAM,EAAE;AACjD,oBAAoB,MAAM,SAAS,GAAG,KAAK,CAAC,qBAAqB,EAAE;AACnE,oBAAoB,MAAM,UAAU,GAAG,SAAS,CAAC,IAAI,GAAG,UAAU,CAAC,IAAI,GAAG,UAAU;AACpF,oBAAoB,MAAM,QAAQ,GAAG,UAAU,GAAG,SAAS,CAAC,KAAK;AACjE,oBAAoB,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE;AAC1H,wBAAwB,6BAA6B,GAAG,QAAQ,GAAG,cAAc;AACjF,wBAAwB,iBAAiB,GAAG,IAAI;AAChD,wBAAwB;AACxB;AACA;AACA,gBAAgB,IAAI,CAAC,iBAAiB,EAAE;AACxC,oBAAoB,6BAA6B,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,UAAU,GAAG,cAAc,CAAC;AAC5F;AACA,gBAAgB,IAAI,6BAA6B,IAAI,IAAI,CAAC,KAAK,CAAC,6BAA6B,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE;AACzH,oBAAoB,oBAAoB,GAAG,6BAA6B;AACxE;AACA;AACA;AACA;AACA,QAAQ,MAAM,6BAA6B,GAAG,oBAAoB,GAAG,aAAa,EAAE;AACpF,QAAQ,IAAI,IAAI,CAAC,KAAK,CAAC,6BAA6B,CAAC,IAAI,CAAC,EAAE;AAC5D,YAAY,oBAAoB,GAAG,6BAA6B;AAChE;AACA,QAAQ,MAAM,CAAC,IAAI,CAAC,yBAAyB,CAAC;AAC9C,QAAQ,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,cAAc,GAAG,MAAM,CAAC,OAAO,CAAC,cAAc;AAC7E,QAAQ,MAAM,CAAC,SAAS,CAAC,UAAU,GAAG,oBAAoB;AAC1D,QAAQ,UAAU,CAAC,MAAM,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,cAAc,GAAG,EAAE,EAAE,EAAE,CAAC;AACxE;AAEA,IAAI,SAAS,kBAAkB,CAAC,SAAS,GAAG,MAAM,EAAE;AACpD,QAAQ,IAAI,EAAE,EAAE,EAAE;AAClB,QAAQ,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,GAAG,MAAM;AACrD,QAAQ,MAAM,EAAE,GAAG,EAAE,6BAA6B,GAAG,EAAE,EAAE,cAAc,GAAG,QAAQ,GAAG,GAAG,OAAO;AAC/F,QAAQ,MAAM,SAAS,GAAG,GAAG,GAAG,SAAS,KAAK,MAAM,GAAG,SAAS,KAAK,MAAM;AAC3E,QAAQ,MAAM,SAAS,GAAG,aAAa,EAAE;AACzC;AACA,QAAQ,MAAM,aAAa,GAAG,SAAS,CAAC,qBAAqB,EAAE;AAC/D,QAAQ,MAAM,MAAM,GAAG,GAAG,GAAG,EAAE,GAAG,CAAC;AACnC;AACA,QAAQ,MAAM,SAAS,GAAG,CAAC,GAAG,MAAM,CAAC,CAAC,GAAG,CAAC,KAAK,IAAI;AACnD,YAAY,MAAM,EAAE,KAAK,EAAE,GAAG,KAAK,CAAC,qBAAqB,EAAE;AAC3D,YAAY,MAAM,SAAS,GAAG,KAAK,CAAC,qBAAqB,EAAE;AAC3D;AACA,YAAY,MAAM,aAAa,GAAG,CAAC,SAAS,CAAC,IAAI,GAAG,aAAa,CAAC,IAAI,IAAI,SAAS;AACnF,YAAY,MAAM,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,aAAa,GAAG,KAAK,GAAG,CAAC,EAAE,aAAa,GAAG,6BAA6B,CAAC;AACnH,YAAY,OAAO,EAAE,KAAK,EAAE,aAAa,EAAE,OAAO,EAAE,YAAY,EAAE;AAClE,SAAS,CAAC;AACV;AACA,QAAQ,IAAI,WAAW,GAAG,IAAI;AAC9B,QAAQ,IAAI,SAAS,EAAE;AACvB,YAAY,MAAM,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,IAAI,IAAI,SAAS,IAAI,IAAI,CAAC,OAAO,CAAC;AAC3E,YAAY,WAAW,GAAG,CAAC,EAAE,GAAG,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,MAAM,GAAG,MAAM,GAAG,KAAK,CAAC,KAAK,MAAM,IAAI,IAAI,EAAE,KAAK,MAAM,GAAG,EAAE,GAAG,IAAI;AAChI;AACA,aAAa;AACb,YAAY,MAAM,KAAK,GAAG,CAAC,GAAG,SAAS,CAAC,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,IAAI,IAAI,SAAS,IAAI,IAAI,CAAC,OAAO,CAAC;AAC1F,YAAY,WAAW,GAAG,CAAC,EAAE,GAAG,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,MAAM,GAAG,MAAM,GAAG,KAAK,CAAC,KAAK,MAAM,IAAI,IAAI,EAAE,KAAK,MAAM,GAAG,EAAE,GAAG,IAAI;AAChI;AACA,QAAQ,IAAI,WAAW,IAAI,IAAI;AAC/B,YAAY;AACZ;AACA,QAAQ,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,GAAG,MAAM;AACvE,QAAQ,SAAS,CAAC,QAAQ,CAAC,EAAE,IAAI,EAAE,SAAS,EAAE,QAAQ,EAAE,cAAc,EAAE,CAAC;AACzE;AACA,IAAI,SAAS,EAAE,CAAC,IAAI,EAAE,EAAE,EAAE;AAC1B,QAAQ,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;AACzB,YAAY,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE;AAC3B;AACA,QAAQ,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC;AAC3B;AAEA,IAAI,SAAS,IAAI,CAAC,IAAI,EAAE;AACxB,QAAQ,IAAI,EAAE;AACd,QAAQ,IAAI,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,EAAE;AAChC,YAAY,IAAI,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,EAAE,IAAI;AACrC,gBAAgB,EAAE,CAAC,MAAM,CAAC;AAC1B,aAAa,CAAC;AACd;AACA,QAAQ,MAAM,cAAc,GAAG,CAAC,EAAE,GAAG,MAAM,KAAK,IAAI,IAAI,MAAM,KAAK,MAAM,GAAG,MAAM,GAAG,MAAM,CAAC,OAAO,MAAM,IAAI,IAAI,EAAE,KAAK,MAAM,GAAG,MAAM,GAAG,EAAE,CAAC,IAAI,CAAC;AAClJ;AACA,QAAQ,IAAI,OAAO,cAAc,KAAK,UAAU,EAAE;AAClD,YAAY,cAAc,CAAC,MAAM,CAAC,CAAC;AACnC;AACA;AAEA,IAAI,MAAM,GAAG;AACb,QAAQ,IAAI;AACZ,QAAQ,eAAe;AACvB,QAAQ,cAAc;AACtB,QAAQ,WAAW;AACnB,QAAQ,sBAAsB;AAC9B,QAAQ,kBAAkB;AAC1B,QAAQ,uBAAuB;AAC/B,QAAQ,uBAAuB;AAC/B,QAAQ,aAAa;AACrB,QAAQ,aAAa;AACrB,QAAQ,iBAAiB;AACzB,QAAQ,EAAE;AACV,QAAQ,OAAO;AACf,KAAK;AACL,IAAI,IAAI,EAAE;AACV,IAAI,OAAO,MAAM;AACjB;;ACvgBe,SAAS,cAAc,CAAC,SAAS,EAAE,OAAO,EAAE,OAAO,EAAE;AACpE,IAAI,IAAI;AACR;AACA,QAAQ,IAAI,EAAE,SAAS,YAAY,OAAO,CAAC,EAAE;AAC7C,YAAY,MAAM,IAAI,KAAK,CAAC,CAAC,sCAAsC,EAAE,OAAO,SAAS,CAAC,CAAC,CAAC;AACxF;AACA,QAAQ,MAAM,QAAQ,GAAG;AACzB,YAAY,oBAAoB,EAAE,SAAS;AAC3C,YAAY,cAAc,EAAE,QAAQ;AACpC,YAAY,cAAc,EAAE,WAAW;AACvC,YAAY,cAAc,EAAE,YAAY;AACxC,YAAY,iBAAiB,EAAE,KAAK;AACpC,YAAY,6BAA6B,EAAE,EAAE;AAC7C,YAAY,GAAG,EAAE,KAAK;AACtB,SAAS;AACT,QAAQ,MAAM,aAAa,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,QAAQ,CAAC,EAAE,OAAO,CAAC;AACjF;AACA,QAAQ,IAAI,MAAM,CAAC,UAAU,CAAC,kCAAkC,CAAC,CAAC,OAAO,EAAE;AAC3E,YAAY,aAAa,CAAC,cAAc,GAAG,MAAM;AACjD;AACA,QAAQ,OAAO,MAAM,CAAC,SAAS,EAAE,aAAa,EAAE,OAAO,CAAC;AACxD;AACA,IAAI,OAAO,CAAC,EAAE;AACd,QAAQ,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;AACxB;AACA;;;;"}